<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Garden – Movement of Love</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      background: #000;
    }

    canvas {
      display: block;
    }

    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      color: white;
      font-family: -apple-system, sans-serif;
    }

    #connectBtn {
      padding: 12px 24px;
      font-size: 1rem;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 25px;
      background: rgba(0, 0, 0, 0.4);
      color: white;
      cursor: pointer;
      backdrop-filter: blur(10px);
    }

    #connectBtn:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    #sliders {
      margin-top: 12px;
      padding: 14px;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 15px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      width: 230px;
    }

    .slider-row {
      margin-bottom: 10px;
    }

    .slider-row:last-child {
      margin-bottom: 0;
    }

    .slider-row label {
      display: block;
      font-size: 0.75rem;
      opacity: 0.8;
      margin-bottom: 4px;
    }

    .slider-row input {
      width: 100%;
      cursor: pointer;
      accent-color: #ff88aa;
    }

    #info {
      margin-top: 10px;
      font-size: 0.85rem;
      opacity: 0.6;
    }

    #title {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 0.9rem;
      letter-spacing: 0.4em;
      opacity: 0.2;
      text-transform: uppercase;
    }
  </style>
</head>

<body>
  <div id="ui">
    <button id="connectBtn" onclick="connect()">Connect Sensor</button>
    <div id="sliders">
      <div class="slider-row">
        <label>Grass Blades: <span id="grassCountLabel">15000</span></label>
        <input type="range" id="grassCount" min="0" max="30000" step="500" value="15000">
      </div>
      <div class="slider-row">
        <label>Grass Height: <span id="grassHeightLabel">1.0x</span></label>
        <input type="range" id="grassHeight" min="0.2" max="3.0" step="0.1" value="1.0">
      </div>
      <div class="slider-row">
        <label>Butterflies: <span id="butterflyCountLabel">12</span></label>
        <input type="range" id="butterflyCount" min="0" max="40" step="1" value="12">
      </div>
    </div>
    <div id="info">↑↓ keys to test bloom</div>
  </div>
  <div id="title">Movement of Love</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // ── BLE ────────────────────────────────────────────────────────────────
    const UART_SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
    const UART_RX_UUID = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';
    let targetDistance = 100, currentDistance = 100;

    async function connect() {
      try {
        document.getElementById('info').textContent = 'Connecting…';
        const device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: 'Adafruit' }],
          optionalServices: [UART_SERVICE_UUID]
        });
        const server = await device.gatt.connect();
        const service = await server.getPrimaryService(UART_SERVICE_UUID);
        const rx = await service.getCharacteristic(UART_RX_UUID);
        await rx.startNotifications();
        rx.addEventListener('characteristicvaluechanged', (e) => {
          const data = new TextDecoder().decode(e.target.value);
          if (data.startsWith('D:')) {
            const v = parseFloat(data.substring(2));
            if (!isNaN(v) && isFinite(v)) {
              targetDistance = Math.max(20, Math.min(150, v));
              document.getElementById('info').textContent = targetDistance.toFixed(0) + ' cm';
            }
          }
        });
        document.getElementById('connectBtn').textContent = 'Connected ✓';
      } catch (err) {
        document.getElementById('info').textContent = err.message;
      }
    }

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp') targetDistance = Math.max(20, targetDistance - 5);
      if (e.key === 'ArrowDown') targetDistance = Math.min(150, targetDistance + 5);
      document.getElementById('info').textContent = targetDistance.toFixed(0) + ' cm';
    });

    // ── Slider wiring ──────────────────────────────────────────────────────
    let grassBladesTarget = 15000;
    let grassHeightScale = 1.0;
    let butterflyMax = 12;

    document.getElementById('grassCount').addEventListener('input', (e) => {
      grassBladesTarget = parseInt(e.target.value);
      document.getElementById('grassCountLabel').textContent = grassBladesTarget;
      rebuildGrass();
    });
    document.getElementById('grassHeight').addEventListener('input', (e) => {
      grassHeightScale = parseFloat(e.target.value);
      document.getElementById('grassHeightLabel').textContent = grassHeightScale.toFixed(1) + 'x';
      rebuildGrass();
    });
    document.getElementById('butterflyCount').addEventListener('input', (e) => {
      butterflyMax = parseInt(e.target.value);
      document.getElementById('butterflyCountLabel').textContent = butterflyMax;
      rebuildButterflies();
    });

    // ── Shader: Grass blade vertex ─────────────────────────────────────────
    const grassVertexShader = `
      uniform float uTime;
      uniform float uBloom;
      uniform float uHeightScale;
      attribute float aRandom;
      attribute float aHeight;
      varying float vHeight;
      varying float vRandom;

      void main() {
        vHeight = position.y;
        vRandom = aRandom;

        vec3 pos = position;
        // Only sway top of blade (position.y > 0)
        float topFactor = clamp(pos.y / (aHeight * uHeightScale), 0.0, 1.0);
        float sway = sin(uTime * 2.0 + aRandom * 6.28318) * 0.15 * topFactor;
        float swayBloom = sin(uTime * 1.3 + aRandom * 6.28318 + 1.0) * 0.2 * topFactor * uBloom;
        pos.x += sway + swayBloom;
        pos.z += cos(uTime * 1.7 + aRandom * 6.28318) * 0.08 * topFactor;
        // Scale height
        pos.y *= uHeightScale;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `;
    const grassFragmentShader = `
      uniform float uBloom;
      varying float vHeight;
      varying float vRandom;

      void main() {
        // Base dark green to light green gradient bottom to top
        vec3 bottom = vec3(0.05, 0.15, 0.04);
        vec3 top = vec3(0.18, 0.55, 0.12);
        // Extra warm bloom tint
        vec3 bloomTint = vec3(0.3, 0.55, 0.1);
        vec3 color = mix(bottom, top, vHeight);
        color = mix(color, bloomTint, uBloom * 0.4 * vHeight);
        float alpha = 1.0;
        gl_FragColor = vec4(color, alpha);
      }
    `;

    // ── Shader: Petal (for ProceduralFlowers and Lily) ─────────────────────
    const petalVertexShader = `
      uniform float uTime;
      uniform float uBloom;
      uniform float uGrowth;
      varying vec2 vUv;
      varying vec3 vNormal;
      varying float vDisplacement;
      void main() {
        vUv = uv;
        vNormal = normal;
        vec3 pos = position;
        float curl = sin(uv.y * 3.14159) * 0.3 * uBloom;
        pos.z += curl * (1.0 - uv.y);
        float wave = sin(uTime * 2.0 + uv.x * 6.28) * 0.05 * uBloom;
        pos.z += wave;
        pos *= uGrowth;
        vDisplacement = curl + wave;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `;
    const petalFragmentShader = `
      uniform vec3 uColorInner;
      uniform vec3 uColorOuter;
      uniform float uBloom;
      uniform float uTime;
      varying vec2 vUv;
      varying vec3 vNormal;
      varying float vDisplacement;
      void main() {
        float gradient = vUv.y;
        vec3 color = mix(uColorInner, uColorOuter, gradient);
        float shimmer = sin(uTime * 3.0 + vUv.x * 10.0 + vUv.y * 10.0) * 0.1 + 0.9;
        color *= shimmer;
        float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.0);
        color += vec3(1.0, 0.8, 0.9) * fresnel * uBloom * 0.3;
        float alpha = smoothstep(0.0, 0.1, vUv.y) * smoothstep(1.0, 0.8, vUv.y);
        alpha *= smoothstep(0.0, 0.2, vUv.x) * smoothstep(1.0, 0.8, vUv.x);
        gl_FragColor = vec4(color, alpha * (0.7 + uBloom * 0.3));
      }
    `;

    // ── Scene ──────────────────────────────────────────────────────────────
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0a0812, 0.018);

    const camera = new THREE.PerspectiveCamera(50, innerWidth / innerHeight, 0.1, 1000);
    camera.position.set(0, 3, 14);
    camera.lookAt(0, 1.5, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // Lights
    scene.add(new THREE.AmbientLight(0x2a1a3a, 0.5));
    const sun = new THREE.DirectionalLight(0xffeedd, 0.8);
    sun.position.set(5, 10, 5);
    scene.add(sun);
    const rimLight = new THREE.PointLight(0xff88aa, 0.9, 25);
    rimLight.position.set(0, 5, -5);
    scene.add(rimLight);
    const groundLight = new THREE.PointLight(0x88ffaa, 0.4, 18);
    groundLight.position.set(0, 0.5, 0);
    scene.add(groundLight);

    // Ground
    const groundGeo = new THREE.PlaneGeometry(60, 40, 60, 60);
    const groundMat = new THREE.ShaderMaterial({
      uniforms: { uTime: { value: 0 }, uBloom: { value: 0 } },
      vertexShader: `
        varying vec2 vUv; varying vec3 vPos;
        void main() { vUv = uv; vPos = position; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
      `,
      fragmentShader: `
        uniform float uTime; uniform float uBloom;
        varying vec2 vUv; varying vec3 vPos;
        void main() {
          float dist = length(vPos.xy) * 0.05;
          vec3 c1 = vec3(0.04, 0.09, 0.03); vec3 c2 = vec3(0.02, 0.04, 0.02);
          vec3 color = mix(c1, c2, dist);
          float glow = exp(-dist * 2.0) * uBloom * 0.12;
          color += vec3(0.1, 0.2, 0.05) * glow;
          gl_FragColor = vec4(color, 1.0);
        }
      `
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // ── SHADER GRASS ───────────────────────────────────────────────────────
    let grassMesh = null;
    const grassUniforms = {
      uTime: { value: 0 },
      uBloom: { value: 0 },
      uHeightScale: { value: 1.0 }
    };

    function makeBladeMesh(worldX, worldZ, random) {
      // Single blade: 3 segment quad strip (6 vertices, 4 tris)
      const segments = 4;
      const h = 0.4 + random * 0.5; // base height (scaled by uniform)
      const w = 0.025 + random * 0.03;
      const positions = [];
      const uvs = [];
      const indices = [];
      const randoms = [];
      const heights = [];

      for (let s = 0; s <= segments; s++) {
        const t = s / segments;
        const taper = 1.0 - t * 0.9;
        positions.push(-w * taper, h * t, 0, w * taper, h * t, 0);
        uvs.push(0, t, 1, t);
        randoms.push(random, random);
        heights.push(h, h);
        if (s < segments) {
          const base = s * 2;
          indices.push(base, base + 1, base + 2, base + 1, base + 3, base + 2);
        }
      }
      return { positions, uvs, indices, randoms, heights, worldX, worldZ, random };
    }

    function rebuildGrass() {
      if (grassMesh) { scene.remove(grassMesh); grassMesh.geometry.dispose(); }

      const count = grassBladesTarget;
      const allPositions = [];
      const allUvs = [];
      const allIndices = [];
      const allRandoms = [];
      const allHeights = [];
      let indexOffset = 0;

      for (let i = 0; i < count; i++) {
        const rad = Math.random() * 20;
        const angle = Math.random() * Math.PI * 2;
        const wx = Math.cos(angle) * rad;
        const wz = Math.sin(angle) * rad - 5;
        const rand = Math.random();
        const blade = makeBladeMesh(wx, wz, rand);

        // Rotation of blade in world
        const rotY = Math.random() * Math.PI * 2;
        const cosY = Math.cos(rotY), sinY = Math.sin(rotY);

        for (let j = 0; j < blade.positions.length; j += 3) {
          const lx = blade.positions[j], ly = blade.positions[j + 1], lz = blade.positions[j + 2];
          // rotate Y then translate to world
          allPositions.push(
            cosY * lx - sinY * lz + wx,
            ly,
            sinY * lx + cosY * lz + wz
          );
        }
        for (let j = 0; j < blade.uvs.length; j++) allUvs.push(blade.uvs[j]);
        for (let j = 0; j < blade.indices.length; j++) allIndices.push(blade.indices[j] + indexOffset);
        for (let j = 0; j < blade.randoms.length; j++) allRandoms.push(blade.randoms[j]);
        for (let j = 0; j < blade.heights.length; j++) allHeights.push(blade.heights[j]);

        indexOffset += (5 * 2); // (segments+1) * 2 verts per blade
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(allPositions), 3));
      geo.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(allUvs), 2));
      geo.setAttribute('aRandom', new THREE.BufferAttribute(new Float32Array(allRandoms), 1));
      geo.setAttribute('aHeight', new THREE.BufferAttribute(new Float32Array(allHeights), 1));
      geo.setIndex(allIndices);

      grassUniforms.uHeightScale.value = grassHeightScale;

      const mat = new THREE.ShaderMaterial({
        uniforms: grassUniforms,
        vertexShader: grassVertexShader,
        fragmentShader: grassFragmentShader,
        side: THREE.DoubleSide
      });

      grassMesh = new THREE.Mesh(geo, mat);
      scene.add(grassMesh);
    }

    rebuildGrass();

    // ── Procedural Flowers (from flowers3d_v2) ────────────────────────────
    class ProceduralFlower {
      constructor(x, z, config) {
        this.group = new THREE.Group();
        this.group.position.set(x, 0, z);
        scene.add(this.group);
        this.config = { petalCount: 8, petalLayers: 3, colorInner: new THREE.Color(0xffccdd), colorOuter: new THREE.Color(0xff6699), maxHeight: 4, delay: 0, petalLength: 1.2, ...config };
        this.growth = 0; this.bloom = 0; this.materials = [];
        this.createStem(); this.createFlowerHead();
      }
      createStem() {
        const curve = new THREE.CatmullRomCurve3([
          new THREE.Vector3(0, 0, 0), new THREE.Vector3(0.05, 0.5, 0.02),
          new THREE.Vector3(-0.03, 1.0, 0), new THREE.Vector3(0.02, 1.5, -0.02), new THREE.Vector3(0, 2.0, 0)
        ]);
        this.stem = new THREE.Mesh(new THREE.TubeGeometry(curve, 20, 0.04, 8, false), new THREE.MeshStandardMaterial({ color: 0x2d5a27, roughness: 0.8 }));
        this.group.add(this.stem);
        for (let i = 0; i < 2; i++) {
          const leaf = new THREE.Mesh(new THREE.PlaneGeometry(0.4, 0.8, 4, 4), new THREE.MeshStandardMaterial({ color: 0x3d7a37, side: THREE.DoubleSide, transparent: true, opacity: 0.9 }));
          leaf.position.y = 0.5 + i * 0.4;
          leaf.rotation.y = i * Math.PI + Math.random();
          leaf.rotation.z = -0.5;
          this.group.add(leaf);
        }
      }
      createFlowerHead() {
        this.flowerHead = new THREE.Group(); this.group.add(this.flowerHead);
        this.center = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), new THREE.MeshStandardMaterial({ color: 0xffdd44, emissive: 0xffaa00, emissiveIntensity: 0.3 }));
        this.flowerHead.add(this.center); this.petals = [];
        for (let layer = 0; layer < this.config.petalLayers; layer++) {
          const count = this.config.petalCount + layer * 2;
          const layerScale = 1 - layer * 0.15;
          for (let i = 0; i < count; i++) {
            const pg = this.createPetal(layer, i, count, layerScale);
            this.petals.push(pg); this.flowerHead.add(pg);
          }
        }
      }
      createPetal(layer, index, total, scale) {
        const shape = new THREE.Shape();
        const w = 0.25 * scale, h = this.config.petalLength * scale;
        shape.moveTo(0, 0); shape.bezierCurveTo(-w, h * 0.3, -w * 0.7, h * 0.7, 0, h); shape.bezierCurveTo(w * 0.7, h * 0.7, w, h * 0.3, 0, 0);
        const innerC = this.config.colorInner.clone().lerp(new THREE.Color(0xffffff), layer * 0.2);
        const outerC = this.config.colorOuter.clone().lerp(new THREE.Color(0xffffff), layer * 0.1);
        const mat = new THREE.ShaderMaterial({ uniforms: { uTime: { value: 0 }, uBloom: { value: 0 }, uGrowth: { value: 0 }, uColorInner: { value: innerC }, uColorOuter: { value: outerC } }, vertexShader: petalVertexShader, fragmentShader: petalFragmentShader, transparent: true, side: THREE.DoubleSide, depthWrite: false });
        this.materials.push(mat);
        const petal = new THREE.Mesh(new THREE.ShapeGeometry(shape, 12), mat);
        const angle = (index / total) * Math.PI * 2;
        petal.userData = { baseRotationX: -Math.PI * 0.3 - layer * 0.15 };
        const pg = new THREE.Group(); pg.add(petal); pg.rotation.y = angle;
        return pg;
      }
      update(globalBloom, time) {
        const adjBloom = Math.max(0, globalBloom - this.config.delay);
        const tg = Math.min(1, adjBloom * 2), tb = Math.max(0, adjBloom - 0.2) * 1.5;
        this.growth += (tg - this.growth) * 0.02; this.bloom += (tb - this.bloom) * 0.03;
        const g = Math.max(0.01, Math.min(1, this.growth)), b = Math.max(0, Math.min(1, this.bloom));
        this.stem.scale.set(0.5 + g * 0.5, g, 0.5 + g * 0.5);
        this.group.rotation.z = Math.sin(time * 1.5 + this.group.position.x) * 0.03 * g;
        this.flowerHead.position.y = this.config.maxHeight * g * 0.5;
        this.flowerHead.scale.setScalar(Math.max(0.01, b));
        this.petals.forEach((pg, i) => {
          const petal = pg.children[0];
          petal.rotation.x = petal.userData.baseRotationX + Math.PI * 0.5 * b + Math.sin(time * 2 + i * 0.3) * 0.05 * b;
          petal.material.uniforms.uTime.value = time;
          petal.material.uniforms.uBloom.value = b;
          petal.material.uniforms.uGrowth.value = g;
        });
        this.center.material.emissiveIntensity = 0.2 + b * 0.6;
        this.center.scale.setScalar(1 + Math.sin(time * 4) * 0.1 * b);
      }
    }

    // ── Lily flower ────────────────────────────────────────────────────────
    // Wider more open petals, white-yellow
    class LilyFlower {
      constructor(x, z, delay) {
        this.group = new THREE.Group();
        this.group.position.set(x, 0, z);
        scene.add(this.group);
        this.delay = delay; this.growth = 0; this.bloom = 0; this.materials = [];
        this.createStem(); this.createHead();
      }
      createStem() {
        const curve = new THREE.CatmullRomCurve3([
          new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0.5, 0.05), new THREE.Vector3(0, 1.2, 0), new THREE.Vector3(0, 2.0, 0)
        ]);
        this.stem = new THREE.Mesh(new THREE.TubeGeometry(curve, 15, 0.03, 6, false), new THREE.MeshStandardMaterial({ color: 0x3a7030, roughness: 0.9 }));
        this.group.add(this.stem);
      }
      createHead() {
        this.head = new THREE.Group(); this.group.add(this.head);
        this.center = new THREE.Mesh(new THREE.SphereGeometry(0.12, 12, 12), new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffaa00, emissiveIntensity: 0.5 }));
        this.head.add(this.center);
        this.petals = [];
        const count = 6;
        for (let i = 0; i < count; i++) {
          const shape = new THREE.Shape();
          shape.moveTo(0, 0); shape.bezierCurveTo(-0.3, 0.4, -0.3, 1.0, 0, 1.5); shape.bezierCurveTo(0.3, 1.0, 0.3, 0.4, 0, 0);
          const mat = new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 }, uBloom: { value: 0 }, uGrowth: { value: 0 }, uColorInner: { value: new THREE.Color(0xffffd0) }, uColorOuter: { value: new THREE.Color(0xfff0a0) } },
            vertexShader: petalVertexShader, fragmentShader: petalFragmentShader,
            transparent: true, side: THREE.DoubleSide, depthWrite: false
          });
          this.materials.push(mat);
          const petal = new THREE.Mesh(new THREE.ShapeGeometry(shape, 10), mat);
          petal.userData = { baseRotX: -Math.PI * 0.15 };
          const pg = new THREE.Group(); pg.add(petal); pg.rotation.y = (i / count) * Math.PI * 2;
          this.petals.push(pg); this.head.add(pg);
        }
      }
      update(globalBloom, time) {
        const adj = Math.max(0, globalBloom - this.delay);
        const tg = Math.min(1, adj * 2), tb = Math.max(0, adj - 0.1) * 1.4;
        this.growth += (tg - this.growth) * 0.025; this.bloom += (tb - this.bloom) * 0.03;
        const g = Math.max(0.01, Math.min(1, this.growth)), b = Math.max(0, Math.min(1, this.bloom));
        this.stem.scale.set(0.6 + g * 0.4, g, 0.6 + g * 0.4);
        this.group.rotation.z = Math.sin(time + this.group.position.x * 2) * 0.025 * g;
        this.head.position.y = 2.5 * g;
        this.head.scale.setScalar(Math.max(0.01, b));
        this.petals.forEach((pg, i) => {
          const p = pg.children[0];
          p.rotation.x = p.userData.baseRotX + Math.PI * 0.45 * b + Math.sin(time * 1.5 + i) * 0.04 * b;
          p.material.uniforms.uTime.value = time;
          p.material.uniforms.uBloom.value = b;
          p.material.uniforms.uGrowth.value = g;
        });
        this.center.material.emissiveIntensity = 0.3 + b * 0.8;
        this.center.scale.setScalar(1 + Math.sin(time * 3.5) * 0.12 * b);
      }
    }

    // Create flowers
    const flowers = [
      new ProceduralFlower(0, 0, { petalCount: 8, petalLayers: 4, colorInner: new THREE.Color(0xffddee), colorOuter: new THREE.Color(0xff6699), maxHeight: 5, delay: 0, petalLength: 1.4 }),
      new ProceduralFlower(-2.5, 1.5, { petalCount: 6, petalLayers: 3, colorInner: new THREE.Color(0xffeeff), colorOuter: new THREE.Color(0xff88aa), maxHeight: 4, delay: 0.1, petalLength: 1.2 }),
      new ProceduralFlower(2.5, 1, { petalCount: 10, petalLayers: 3, colorInner: new THREE.Color(0xffccdd), colorOuter: new THREE.Color(0xee5577), maxHeight: 4.5, delay: 0.1, petalLength: 1.3 }),
      new ProceduralFlower(-1.5, -1.5, { petalCount: 8, petalLayers: 3, colorInner: new THREE.Color(0xeeddff), colorOuter: new THREE.Color(0xaa66cc), maxHeight: 3.5, delay: 0.2, petalLength: 1.1 }),
      new ProceduralFlower(1.8, -1.2, { petalCount: 6, petalLayers: 3, colorInner: new THREE.Color(0xffeecc), colorOuter: new THREE.Color(0xffaa66), maxHeight: 3.8, delay: 0.15, petalLength: 1.0 }),
    ];

    // Lilies in the background/sides
    const lilies = [
      new LilyFlower(-4.5, -0.5, 0.15),
      new LilyFlower(4.2, -1.5, 0.2),
      new LilyFlower(-3.2, 2.5, 0.25),
      new LilyFlower(3.8, 2.0, 0.3),
      new LilyFlower(0.5, -3.0, 0.18),
    ];

    // ── Butterflies ─────────────────────────────────────────────────────────
    // Simple procedural butterfly: two wing quads + body
    const butterflyData = [];

    function createWingShape(mirror) {
      const shape = new THREE.Shape();
      if (!mirror) {
        shape.moveTo(0, 0);
        shape.bezierCurveTo(-0.5, 0.2, -0.8, 0.6, -0.5, 1.0);
        shape.bezierCurveTo(-0.3, 1.3, -0.1, 1.1, 0, 0.8);
        shape.bezierCurveTo(0.1, 0.5, 0.05, 0.2, 0, 0);
      } else {
        shape.moveTo(0, 0);
        shape.bezierCurveTo(0.5, 0.2, 0.8, 0.6, 0.5, 1.0);
        shape.bezierCurveTo(0.3, 1.3, 0.1, 1.1, 0, 0.8);
        shape.bezierCurveTo(-0.1, 0.5, -0.05, 0.2, 0, 0);
      }
      return shape;
    }

    const butterflyColors = [
      [0xff88cc, 0xffaaee],
      [0x88ccff, 0xaaddff],
      [0xffcc88, 0xffeebb],
      [0xaaff88, 0xccffaa],
      [0xcc88ff, 0xeeddff],
    ];

    let butterflies = [];

    function rebuildButterflies() {
      butterflies.forEach(b => scene.remove(b.group));
      butterflies = [];

      for (let i = 0; i < butterflyMax; i++) {
        const group = new THREE.Group();
        const colors = butterflyColors[i % butterflyColors.length];
        const wingMat = new THREE.MeshStandardMaterial({
          color: colors[0], transparent: true, opacity: 0.85,
          side: THREE.DoubleSide, emissive: colors[1], emissiveIntensity: 0.1
        });
        const wingL = new THREE.Mesh(new THREE.ShapeGeometry(createWingShape(false), 8), wingMat.clone());
        const wingR = new THREE.Mesh(new THREE.ShapeGeometry(createWingShape(true), 8), wingMat.clone());
        wingL.scale.setScalar(0.35);
        wingR.scale.setScalar(0.35);
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.015, 0.35, 6), new THREE.MeshStandardMaterial({ color: 0x221100, roughness: 0.7 }));
        body.rotation.z = Math.PI / 2;
        group.add(wingL, wingR, body);

        // Random orbit parameters
        const orbitR = 4 + Math.random() * 10;
        const orbitY = 1.5 + Math.random() * 3;
        const orbitSpeed = 0.2 + Math.random() * 0.4;
        const phase = Math.random() * Math.PI * 2;
        const flapSpeed = 4 + Math.random() * 3;

        group.position.set(Math.cos(phase) * orbitR, orbitY, Math.sin(phase) * orbitR - 3);
        scene.add(group);
        butterflies.push({ group, wingL, wingR, orbitR, orbitY, orbitSpeed, phase, flapSpeed });
      }
    }

    rebuildButterflies();

    // ── Pollen particles ───────────────────────────────────────────────────
    const pollenCount = 200;
    const pollenGeo = new THREE.BufferGeometry();
    const pollenPos = new Float32Array(pollenCount * 3);
    const pollenVel = [];
    for (let i = 0; i < pollenCount; i++) {
      const i3 = i * 3;
      pollenPos[i3] = (Math.random() - 0.5) * 15;
      pollenPos[i3 + 1] = Math.random() * 8;
      pollenPos[i3 + 2] = (Math.random() - 0.5) * 10;
      pollenVel.push({ x: (Math.random() - 0.5) * 0.01, y: Math.random() * 0.02 + 0.005, z: (Math.random() - 0.5) * 0.01 });
    }
    pollenGeo.setAttribute('position', new THREE.BufferAttribute(pollenPos, 3));
    const pollenMat = new THREE.PointsMaterial({ size: 0.07, color: 0xffffcc, transparent: true, opacity: 0, blending: THREE.AdditiveBlending });
    scene.add(new THREE.Points(pollenGeo, pollenMat));

    // ── Animation loop ──────────────────────────────────────────────────────
    let time = 0, bloom = 0;

    function animate() {
      requestAnimationFrame(animate);
      time += 0.016;

      currentDistance += (targetDistance - currentDistance) * 0.05;
      const targetBloom = 1 - Math.min(1, Math.max(0, (currentDistance - 20) / 80));
      bloom += (targetBloom - bloom) * 0.02;

      // Grass
      grassUniforms.uTime.value = time;
      grassUniforms.uBloom.value = bloom;

      // Ground
      groundMat.uniforms.uTime.value = time;
      groundMat.uniforms.uBloom.value = bloom;

      // Flowers
      flowers.forEach(f => f.update(bloom, time));
      lilies.forEach(l => l.update(bloom, time));

      // Butterflies
      butterflies.forEach((b, i) => {
        const angle = b.phase + time * b.orbitSpeed;
        const driftY = Math.sin(time * 0.7 + i) * 0.3;
        b.group.position.x = Math.cos(angle) * b.orbitR;
        b.group.position.y = b.orbitY + driftY;
        b.group.position.z = Math.sin(angle) * b.orbitR - 3;
        b.group.rotation.y = -angle + Math.PI / 2;

        // Wing flap
        const flapAngle = Math.abs(Math.sin(time * b.flapSpeed)) * 0.9;
        b.wingL.rotation.y = flapAngle;
        b.wingR.rotation.y = -flapAngle;

        // Speed up with bloom
        b.group.position.y += bloom * 0.5;
      });

      // Pollen
      const pPos = pollenGeo.attributes.position.array;
      pollenMat.opacity = bloom * 0.7;
      for (let i = 0; i < pollenCount; i++) {
        const i3 = i * 3;
        pPos[i3] += pollenVel[i].x + Math.sin(time + i) * 0.003;
        pPos[i3 + 1] += pollenVel[i].y * bloom;
        pPos[i3 + 2] += pollenVel[i].z;
        if (pPos[i3 + 1] > 10 || Math.abs(pPos[i3]) > 10) {
          pPos[i3] = (Math.random() - 0.5) * 10;
          pPos[i3 + 1] = Math.random() * 2;
          pPos[i3 + 2] = (Math.random() - 0.5) * 8;
        }
      }
      pollenGeo.attributes.position.needsUpdate = true;

      // Camera gentle orbit
      camera.position.x = Math.sin(time * 0.08) * 2.5;
      camera.position.y = 3 + Math.sin(time * 0.06) * 0.4 + bloom * 1.5;
      camera.lookAt(0, 2 + bloom * 1.5, 0);

      // Dynamic lighting
      rimLight.intensity = 0.4 + bloom * 0.9;
      groundLight.intensity = bloom * 0.5;

      // Sky color
      renderer.setClearColor(new THREE.Color(
        0.04 + bloom * 0.03,
        0.03 + bloom * 0.02,
        0.07 + bloom * 0.05
      ));

      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>

</html>
