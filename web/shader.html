<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shader Bloom</title>
  <style>
    * { margin: 0; padding: 0; }
    body {
      overflow: hidden;
      background: #000;
    }
    canvas { display: block; }

    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      color: white;
      font-family: -apple-system, sans-serif;
    }

    #connectBtn {
      padding: 12px 24px;
      font-size: 1rem;
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 25px;
      background: rgba(0,0,0,0.4);
      color: white;
      cursor: pointer;
      backdrop-filter: blur(10px);
    }

    #connectBtn:hover {
      background: rgba(255,255,255,0.1);
    }

    #info {
      margin-top: 10px;
      font-size: 0.85rem;
      opacity: 0.6;
    }

    #title {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 0.9rem;
      letter-spacing: 0.4em;
      opacity: 0.2;
      text-transform: uppercase;
    }
  </style>
</head>
<body>
  <div id="ui">
    <button id="connectBtn" onclick="connect()">Connect Sensor</button>
    <div id="info">↑↓ keys to test</div>
  </div>

  <div id="title">Movement of Love</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // BLE
    const UART_SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
    const UART_RX_UUID = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';

    let targetDistance = 100;
    let currentDistance = 100;

    async function connect() {
      try {
        document.getElementById('info').textContent = 'Connecting...';
        const device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: 'Adafruit' }],
          optionalServices: [UART_SERVICE_UUID]
        });
        const server = await device.gatt.connect();
        const service = await server.getPrimaryService(UART_SERVICE_UUID);
        const rx = await service.getCharacteristic(UART_RX_UUID);
        await rx.startNotifications();

        rx.addEventListener('characteristicvaluechanged', (e) => {
          const data = new TextDecoder().decode(e.target.value);
          if (data.startsWith('D:')) {
            const value = parseFloat(data.substring(2));
            if (!isNaN(value) && isFinite(value)) {
              targetDistance = Math.max(20, Math.min(150, value));
              document.getElementById('info').textContent = targetDistance.toFixed(0) + ' cm';
            }
          }
        });

        document.getElementById('connectBtn').textContent = 'Connected';
      } catch (err) {
        document.getElementById('info').textContent = err.message;
      }
    }

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp') targetDistance = Math.max(20, targetDistance - 5);
      if (e.key === 'ArrowDown') targetDistance = Math.min(150, targetDistance + 5);
      document.getElementById('info').textContent = targetDistance.toFixed(0) + ' cm';
    });

    // Vertex Shader
    const vertexShader = `
      uniform float uTime;
      uniform float uBloom;

      varying vec2 vUv;
      varying vec3 vNormal;
      varying vec3 vPosition;
      varying float vDisplacement;

      // Simplex noise functions
      vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
      vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

      float snoise(vec3 v) {
        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

        vec3 i  = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);

        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min(g.xyz, l.zxy);
        vec3 i2 = max(g.xyz, l.zxy);

        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;

        i = mod289(i);
        vec4 p = permute(permute(permute(
          i.z + vec4(0.0, i1.z, i2.z, 1.0))
          + i.y + vec4(0.0, i1.y, i2.y, 1.0))
          + i.x + vec4(0.0, i1.x, i2.x, 1.0));

        float n_ = 0.142857142857;
        vec3 ns = n_ * D.wyz - D.xzx;

        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_);

        vec4 x = x_ *ns.x + ns.yyyy;
        vec4 y = y_ *ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);

        vec4 b0 = vec4(x.xy, y.xy);
        vec4 b1 = vec4(x.zw, y.zw);

        vec4 s0 = floor(b0)*2.0 + 1.0;
        vec4 s1 = floor(b1)*2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));

        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;

        vec3 p0 = vec3(a0.xy, h.x);
        vec3 p1 = vec3(a0.zw, h.y);
        vec3 p2 = vec3(a1.xy, h.z);
        vec3 p3 = vec3(a1.zw, h.w);

        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
        p0 *= norm.x;
        p1 *= norm.y;
        p2 *= norm.z;
        p3 *= norm.w;

        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
      }

      void main() {
        vUv = uv;
        vNormal = normal;

        vec3 pos = position;

        // Petal-like displacement
        float petalCount = 6.0;
        float angle = atan(pos.y, pos.x);
        float radius = length(pos.xy);

        // Create petal pattern
        float petal = sin(angle * petalCount + uTime * 0.5) * 0.5 + 0.5;
        petal = pow(petal, 0.5);

        // Noise displacement
        float noiseScale = 1.5;
        float noise1 = snoise(pos * noiseScale + uTime * 0.3);
        float noise2 = snoise(pos * noiseScale * 2.0 - uTime * 0.2);

        // Combine displacements
        float displacement = 0.0;
        displacement += petal * 0.8 * uBloom;
        displacement += noise1 * 0.3 * uBloom;
        displacement += noise2 * 0.15 * uBloom;

        // Breathing effect
        float breathe = sin(uTime * 2.0) * 0.1 * uBloom;
        displacement += breathe;

        // Apply displacement along normal
        pos += normal * displacement;

        vDisplacement = displacement;
        vPosition = pos;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `;

    // Fragment Shader
    const fragmentShader = `
      uniform float uTime;
      uniform float uBloom;

      varying vec2 vUv;
      varying vec3 vNormal;
      varying vec3 vPosition;
      varying float vDisplacement;

      void main() {
        // Base color gradient (pink to purple to blue)
        vec3 color1 = vec3(1.0, 0.4, 0.6);  // Pink
        vec3 color2 = vec3(0.8, 0.3, 0.9);  // Purple
        vec3 color3 = vec3(0.3, 0.4, 0.9);  // Blue

        // Mix colors based on position and bloom
        float t = vUv.y + sin(vUv.x * 6.28 + uTime) * 0.1;
        vec3 baseColor = mix(color3, color1, t * uBloom);
        baseColor = mix(baseColor, color2, vDisplacement * 0.5);

        // Fresnel effect (edge glow)
        vec3 viewDir = normalize(cameraPosition - vPosition);
        float fresnel = 1.0 - max(dot(viewDir, vNormal), 0.0);
        fresnel = pow(fresnel, 2.0);

        // Add glow at edges
        vec3 glowColor = vec3(1.0, 0.6, 0.8);
        baseColor += glowColor * fresnel * uBloom * 0.8;

        // Brightness based on displacement
        float brightness = 0.6 + vDisplacement * 0.5 + uBloom * 0.3;
        baseColor *= brightness;

        // Inner glow
        float innerGlow = smoothstep(0.0, 0.5, vDisplacement) * uBloom;
        baseColor += vec3(1.0, 0.8, 0.9) * innerGlow * 0.3;

        // Pulsing highlight
        float pulse = sin(uTime * 3.0) * 0.5 + 0.5;
        baseColor += vec3(1.0) * pulse * fresnel * uBloom * 0.2;

        // Fade when not blooming
        float alpha = 0.3 + uBloom * 0.7;

        gl_FragColor = vec4(baseColor, alpha);
      }
    `;

    // Three.js Setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x050510);
    document.body.appendChild(renderer.domElement);

    // Create shader material
    const uniforms = {
      uTime: { value: 0 },
      uBloom: { value: 0 }
    };

    const material = new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms,
      transparent: true,
      side: THREE.DoubleSide
    });

    // Create organic sphere geometry
    const geometry = new THREE.IcosahedronGeometry(1.5, 64);
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    // Background particles
    const particleCount = 500;
    const particleGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleSpeeds = [];

    for (let i = 0; i < particleCount; i++) {
      const i3 = i * 3;
      const radius = 3 + Math.random() * 8;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;

      particlePositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
      particlePositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
      particlePositions[i3 + 2] = radius * Math.cos(phi);

      particleSpeeds.push({
        x: (Math.random() - 0.5) * 0.005,
        y: (Math.random() - 0.5) * 0.005,
        z: (Math.random() - 0.5) * 0.005
      });
    }

    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));

    const particleMaterial = new THREE.PointsMaterial({
      size: 0.03,
      color: 0xffffff,
      transparent: true,
      opacity: 0.6,
      blending: THREE.AdditiveBlending
    });

    const particles = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(particles);

    // Glow sprite behind main shape
    const glowTexture = createGlowTexture();
    const glowMaterial = new THREE.SpriteMaterial({
      map: glowTexture,
      transparent: true,
      blending: THREE.AdditiveBlending,
      opacity: 0
    });
    const glow = new THREE.Sprite(glowMaterial);
    glow.scale.set(8, 8, 1);
    scene.add(glow);

    function createGlowTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');

      const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
      gradient.addColorStop(0, 'rgba(255, 150, 200, 1)');
      gradient.addColorStop(0.3, 'rgba(200, 100, 255, 0.5)');
      gradient.addColorStop(0.6, 'rgba(100, 100, 255, 0.2)');
      gradient.addColorStop(1, 'rgba(0, 0, 50, 0)');

      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 256, 256);

      return new THREE.CanvasTexture(canvas);
    }

    // Animation
    let time = 0;
    let bloom = 0;

    function animate() {
      requestAnimationFrame(animate);
      time += 0.016;

      // Smooth distance and bloom
      currentDistance += (targetDistance - currentDistance) * 0.05;
      const targetBloom = 1 - Math.min(1, Math.max(0, (currentDistance - 20) / 80));
      bloom += (targetBloom - bloom) * 0.03;

      // Update uniforms
      uniforms.uTime.value = time;
      uniforms.uBloom.value = bloom;

      // Rotate mesh slowly
      mesh.rotation.y = time * 0.1;
      mesh.rotation.x = Math.sin(time * 0.2) * 0.2;

      // Scale based on bloom
      const scale = 0.8 + bloom * 0.5;
      mesh.scale.set(scale, scale, scale);

      // Glow intensity
      glowMaterial.opacity = bloom * 0.5;
      glow.scale.set(6 + bloom * 4, 6 + bloom * 4, 1);

      // Update particles
      const positions = particleGeometry.attributes.position.array;
      particleMaterial.opacity = 0.3 + bloom * 0.5;

      for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        const speed = particleSpeeds[i];

        // Move particles
        positions[i3] += speed.x;
        positions[i3 + 1] += speed.y + bloom * 0.002;
        positions[i3 + 2] += speed.z;

        // Attract to center when blooming
        if (bloom > 0.3) {
          positions[i3] += (0 - positions[i3]) * 0.001 * bloom;
          positions[i3 + 1] += (0 - positions[i3 + 1]) * 0.001 * bloom;
          positions[i3 + 2] += (0 - positions[i3 + 2]) * 0.001 * bloom;
        }

        // Wrap around
        const dist = Math.sqrt(
          positions[i3] ** 2 +
          positions[i3 + 1] ** 2 +
          positions[i3 + 2] ** 2
        );

        if (dist > 10 || dist < 2) {
          const radius = 3 + Math.random() * 5;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;
          positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
          positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
          positions[i3 + 2] = radius * Math.cos(phi);
        }
      }
      particleGeometry.attributes.position.needsUpdate = true;

      // Rotate particles
      particles.rotation.y = time * 0.05;

      // Background color
      const r = 0.02 + bloom * 0.03;
      const g = 0.01 + bloom * 0.01;
      const b = 0.06 + bloom * 0.02;
      renderer.setClearColor(new THREE.Color(r, g, b));

      renderer.render(scene, camera);
    }

    animate();

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
