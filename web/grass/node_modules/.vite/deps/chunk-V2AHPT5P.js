import {
  Color,
  Material,
  MathUtils,
  Matrix3,
  Matrix4,
  MeshBasicMaterial,
  MeshLambertMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshToonMaterial,
  ShaderChunk,
  Texture,
  Vector2,
  Vector3,
  Vector4
} from "./chunk-PZ6HF7LT.js";
import {
  __commonJS,
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/glsl-tokenizer/lib/literals.js
var require_literals = __commonJS({
  "node_modules/glsl-tokenizer/lib/literals.js"(exports, module) {
    module.exports = [
      // current
      "precision",
      "highp",
      "mediump",
      "lowp",
      "attribute",
      "const",
      "uniform",
      "varying",
      "break",
      "continue",
      "do",
      "for",
      "while",
      "if",
      "else",
      "in",
      "out",
      "inout",
      "float",
      "int",
      "uint",
      "void",
      "bool",
      "true",
      "false",
      "discard",
      "return",
      "mat2",
      "mat3",
      "mat4",
      "vec2",
      "vec3",
      "vec4",
      "ivec2",
      "ivec3",
      "ivec4",
      "bvec2",
      "bvec3",
      "bvec4",
      "sampler1D",
      "sampler2D",
      "sampler3D",
      "samplerCube",
      "sampler1DShadow",
      "sampler2DShadow",
      "struct",
      "asm",
      "class",
      "union",
      "enum",
      "typedef",
      "template",
      "this",
      "packed",
      "goto",
      "switch",
      "default",
      "inline",
      "noinline",
      "volatile",
      "public",
      "static",
      "extern",
      "external",
      "interface",
      "long",
      "short",
      "double",
      "half",
      "fixed",
      "unsigned",
      "input",
      "output",
      "hvec2",
      "hvec3",
      "hvec4",
      "dvec2",
      "dvec3",
      "dvec4",
      "fvec2",
      "fvec3",
      "fvec4",
      "sampler2DRect",
      "sampler3DRect",
      "sampler2DRectShadow",
      "sizeof",
      "cast",
      "namespace",
      "using"
    ];
  }
});

// node_modules/glsl-tokenizer/lib/operators.js
var require_operators = __commonJS({
  "node_modules/glsl-tokenizer/lib/operators.js"(exports, module) {
    module.exports = [
      "<<=",
      ">>=",
      "++",
      "--",
      "<<",
      ">>",
      "<=",
      ">=",
      "==",
      "!=",
      "&&",
      "||",
      "+=",
      "-=",
      "*=",
      "/=",
      "%=",
      "&=",
      "^^",
      "^=",
      "|=",
      "(",
      ")",
      "[",
      "]",
      ".",
      "!",
      "~",
      "*",
      "/",
      "%",
      "+",
      "-",
      "<",
      ">",
      "&",
      "^",
      "|",
      "?",
      ":",
      "=",
      ",",
      ";",
      "{",
      "}"
    ];
  }
});

// node_modules/glsl-tokenizer/lib/builtins.js
var require_builtins = __commonJS({
  "node_modules/glsl-tokenizer/lib/builtins.js"(exports, module) {
    module.exports = [
      // Keep this list sorted
      "abs",
      "acos",
      "all",
      "any",
      "asin",
      "atan",
      "ceil",
      "clamp",
      "cos",
      "cross",
      "dFdx",
      "dFdy",
      "degrees",
      "distance",
      "dot",
      "equal",
      "exp",
      "exp2",
      "faceforward",
      "floor",
      "fract",
      "gl_BackColor",
      "gl_BackLightModelProduct",
      "gl_BackLightProduct",
      "gl_BackMaterial",
      "gl_BackSecondaryColor",
      "gl_ClipPlane",
      "gl_ClipVertex",
      "gl_Color",
      "gl_DepthRange",
      "gl_DepthRangeParameters",
      "gl_EyePlaneQ",
      "gl_EyePlaneR",
      "gl_EyePlaneS",
      "gl_EyePlaneT",
      "gl_Fog",
      "gl_FogCoord",
      "gl_FogFragCoord",
      "gl_FogParameters",
      "gl_FragColor",
      "gl_FragCoord",
      "gl_FragData",
      "gl_FragDepth",
      "gl_FragDepthEXT",
      "gl_FrontColor",
      "gl_FrontFacing",
      "gl_FrontLightModelProduct",
      "gl_FrontLightProduct",
      "gl_FrontMaterial",
      "gl_FrontSecondaryColor",
      "gl_LightModel",
      "gl_LightModelParameters",
      "gl_LightModelProducts",
      "gl_LightProducts",
      "gl_LightSource",
      "gl_LightSourceParameters",
      "gl_MaterialParameters",
      "gl_MaxClipPlanes",
      "gl_MaxCombinedTextureImageUnits",
      "gl_MaxDrawBuffers",
      "gl_MaxFragmentUniformComponents",
      "gl_MaxLights",
      "gl_MaxTextureCoords",
      "gl_MaxTextureImageUnits",
      "gl_MaxTextureUnits",
      "gl_MaxVaryingFloats",
      "gl_MaxVertexAttribs",
      "gl_MaxVertexTextureImageUnits",
      "gl_MaxVertexUniformComponents",
      "gl_ModelViewMatrix",
      "gl_ModelViewMatrixInverse",
      "gl_ModelViewMatrixInverseTranspose",
      "gl_ModelViewMatrixTranspose",
      "gl_ModelViewProjectionMatrix",
      "gl_ModelViewProjectionMatrixInverse",
      "gl_ModelViewProjectionMatrixInverseTranspose",
      "gl_ModelViewProjectionMatrixTranspose",
      "gl_MultiTexCoord0",
      "gl_MultiTexCoord1",
      "gl_MultiTexCoord2",
      "gl_MultiTexCoord3",
      "gl_MultiTexCoord4",
      "gl_MultiTexCoord5",
      "gl_MultiTexCoord6",
      "gl_MultiTexCoord7",
      "gl_Normal",
      "gl_NormalMatrix",
      "gl_NormalScale",
      "gl_ObjectPlaneQ",
      "gl_ObjectPlaneR",
      "gl_ObjectPlaneS",
      "gl_ObjectPlaneT",
      "gl_Point",
      "gl_PointCoord",
      "gl_PointParameters",
      "gl_PointSize",
      "gl_Position",
      "gl_ProjectionMatrix",
      "gl_ProjectionMatrixInverse",
      "gl_ProjectionMatrixInverseTranspose",
      "gl_ProjectionMatrixTranspose",
      "gl_SecondaryColor",
      "gl_TexCoord",
      "gl_TextureEnvColor",
      "gl_TextureMatrix",
      "gl_TextureMatrixInverse",
      "gl_TextureMatrixInverseTranspose",
      "gl_TextureMatrixTranspose",
      "gl_Vertex",
      "greaterThan",
      "greaterThanEqual",
      "inversesqrt",
      "length",
      "lessThan",
      "lessThanEqual",
      "log",
      "log2",
      "matrixCompMult",
      "max",
      "min",
      "mix",
      "mod",
      "normalize",
      "not",
      "notEqual",
      "pow",
      "radians",
      "reflect",
      "refract",
      "sign",
      "sin",
      "smoothstep",
      "sqrt",
      "step",
      "tan",
      "texture2D",
      "texture2DLod",
      "texture2DProj",
      "texture2DProjLod",
      "textureCube",
      "textureCubeLod",
      "texture2DLodEXT",
      "texture2DProjLodEXT",
      "textureCubeLodEXT",
      "texture2DGradEXT",
      "texture2DProjGradEXT",
      "textureCubeGradEXT"
    ];
  }
});

// node_modules/glsl-tokenizer/lib/literals-300es.js
var require_literals_300es = __commonJS({
  "node_modules/glsl-tokenizer/lib/literals-300es.js"(exports, module) {
    var v100 = require_literals();
    module.exports = v100.slice().concat([
      "layout",
      "centroid",
      "smooth",
      "case",
      "mat2x2",
      "mat2x3",
      "mat2x4",
      "mat3x2",
      "mat3x3",
      "mat3x4",
      "mat4x2",
      "mat4x3",
      "mat4x4",
      "uvec2",
      "uvec3",
      "uvec4",
      "samplerCubeShadow",
      "sampler2DArray",
      "sampler2DArrayShadow",
      "isampler2D",
      "isampler3D",
      "isamplerCube",
      "isampler2DArray",
      "usampler2D",
      "usampler3D",
      "usamplerCube",
      "usampler2DArray",
      "coherent",
      "restrict",
      "readonly",
      "writeonly",
      "resource",
      "atomic_uint",
      "noperspective",
      "patch",
      "sample",
      "subroutine",
      "common",
      "partition",
      "active",
      "filter",
      "image1D",
      "image2D",
      "image3D",
      "imageCube",
      "iimage1D",
      "iimage2D",
      "iimage3D",
      "iimageCube",
      "uimage1D",
      "uimage2D",
      "uimage3D",
      "uimageCube",
      "image1DArray",
      "image2DArray",
      "iimage1DArray",
      "iimage2DArray",
      "uimage1DArray",
      "uimage2DArray",
      "image1DShadow",
      "image2DShadow",
      "image1DArrayShadow",
      "image2DArrayShadow",
      "imageBuffer",
      "iimageBuffer",
      "uimageBuffer",
      "sampler1DArray",
      "sampler1DArrayShadow",
      "isampler1D",
      "isampler1DArray",
      "usampler1D",
      "usampler1DArray",
      "isampler2DRect",
      "usampler2DRect",
      "samplerBuffer",
      "isamplerBuffer",
      "usamplerBuffer",
      "sampler2DMS",
      "isampler2DMS",
      "usampler2DMS",
      "sampler2DMSArray",
      "isampler2DMSArray",
      "usampler2DMSArray"
    ]);
  }
});

// node_modules/glsl-tokenizer/lib/builtins-300es.js
var require_builtins_300es = __commonJS({
  "node_modules/glsl-tokenizer/lib/builtins-300es.js"(exports, module) {
    var v100 = require_builtins();
    v100 = v100.slice().filter(function(b2) {
      return !/^(gl\_|texture)/.test(b2);
    });
    module.exports = v100.concat([
      // the updated gl_ constants
      "gl_VertexID",
      "gl_InstanceID",
      "gl_Position",
      "gl_PointSize",
      "gl_FragCoord",
      "gl_FrontFacing",
      "gl_FragDepth",
      "gl_PointCoord",
      "gl_MaxVertexAttribs",
      "gl_MaxVertexUniformVectors",
      "gl_MaxVertexOutputVectors",
      "gl_MaxFragmentInputVectors",
      "gl_MaxVertexTextureImageUnits",
      "gl_MaxCombinedTextureImageUnits",
      "gl_MaxTextureImageUnits",
      "gl_MaxFragmentUniformVectors",
      "gl_MaxDrawBuffers",
      "gl_MinProgramTexelOffset",
      "gl_MaxProgramTexelOffset",
      "gl_DepthRangeParameters",
      "gl_DepthRange",
      "trunc",
      "round",
      "roundEven",
      "isnan",
      "isinf",
      "floatBitsToInt",
      "floatBitsToUint",
      "intBitsToFloat",
      "uintBitsToFloat",
      "packSnorm2x16",
      "unpackSnorm2x16",
      "packUnorm2x16",
      "unpackUnorm2x16",
      "packHalf2x16",
      "unpackHalf2x16",
      "outerProduct",
      "transpose",
      "determinant",
      "inverse",
      "texture",
      "textureSize",
      "textureProj",
      "textureLod",
      "textureOffset",
      "texelFetch",
      "texelFetchOffset",
      "textureProjOffset",
      "textureLodOffset",
      "textureProjLod",
      "textureProjLodOffset",
      "textureGrad",
      "textureGradOffset",
      "textureProjGrad",
      "textureProjGradOffset"
    ]);
  }
});

// node_modules/glsl-tokenizer/index.js
var require_glsl_tokenizer = __commonJS({
  "node_modules/glsl-tokenizer/index.js"(exports, module) {
    module.exports = tokenize;
    var literals100 = require_literals();
    var operators = require_operators();
    var builtins100 = require_builtins();
    var literals300es = require_literals_300es();
    var builtins300es = require_builtins_300es();
    var NORMAL = 999;
    var TOKEN = 9999;
    var BLOCK_COMMENT = 0;
    var LINE_COMMENT = 1;
    var PREPROCESSOR = 2;
    var OPERATOR = 3;
    var INTEGER = 4;
    var FLOAT = 5;
    var IDENT = 6;
    var BUILTIN = 7;
    var KEYWORD = 8;
    var WHITESPACE = 9;
    var EOF = 10;
    var HEX = 11;
    var map = [
      "block-comment",
      "line-comment",
      "preprocessor",
      "operator",
      "integer",
      "float",
      "ident",
      "builtin",
      "keyword",
      "whitespace",
      "eof",
      "integer"
    ];
    function tokenize(opt) {
      var i = 0, total = 0, mode = NORMAL, c, last, content = [], tokens = [], token_idx = 0, token_offs = 0, line = 1, col = 0, start = 0, isnum = false, isoperator = false, input = "", len;
      opt = opt || {};
      var allBuiltins = builtins100;
      var allLiterals = literals100;
      if (opt.version === "300 es") {
        allBuiltins = builtins300es;
        allLiterals = literals300es;
      }
      var builtinsDict = {}, literalsDict = {};
      for (var i = 0; i < allBuiltins.length; i++) {
        builtinsDict[allBuiltins[i]] = true;
      }
      for (var i = 0; i < allLiterals.length; i++) {
        literalsDict[allLiterals[i]] = true;
      }
      return function(data) {
        tokens = [];
        if (data !== null) return write(data);
        return end();
      };
      function token(data) {
        if (data.length) {
          tokens.push({
            type: map[mode],
            data,
            position: start,
            line,
            column: col
          });
        }
      }
      function write(chunk) {
        i = 0;
        if (chunk.toString) chunk = chunk.toString();
        input += chunk.replace(/\r\n/g, "\n");
        len = input.length;
        var last2;
        while (c = input[i], i < len) {
          last2 = i;
          switch (mode) {
            case BLOCK_COMMENT:
              i = block_comment();
              break;
            case LINE_COMMENT:
              i = line_comment();
              break;
            case PREPROCESSOR:
              i = preprocessor();
              break;
            case OPERATOR:
              i = operator();
              break;
            case INTEGER:
              i = integer();
              break;
            case HEX:
              i = hex();
              break;
            case FLOAT:
              i = decimal();
              break;
            case TOKEN:
              i = readtoken();
              break;
            case WHITESPACE:
              i = whitespace();
              break;
            case NORMAL:
              i = normal();
              break;
          }
          if (last2 !== i) {
            switch (input[last2]) {
              case "\n":
                col = 0;
                ++line;
                break;
              default:
                ++col;
                break;
            }
          }
        }
        total += i;
        input = input.slice(i);
        return tokens;
      }
      function end(chunk) {
        if (content.length) {
          token(content.join(""));
        }
        mode = EOF;
        token("(eof)");
        return tokens;
      }
      function normal() {
        content = content.length ? [] : content;
        if (last === "/" && c === "*") {
          start = total + i - 1;
          mode = BLOCK_COMMENT;
          last = c;
          return i + 1;
        }
        if (last === "/" && c === "/") {
          start = total + i - 1;
          mode = LINE_COMMENT;
          last = c;
          return i + 1;
        }
        if (c === "#") {
          mode = PREPROCESSOR;
          start = total + i;
          return i;
        }
        if (/\s/.test(c)) {
          mode = WHITESPACE;
          start = total + i;
          return i;
        }
        isnum = /\d/.test(c);
        isoperator = /[^\w_]/.test(c);
        start = total + i;
        mode = isnum ? INTEGER : isoperator ? OPERATOR : TOKEN;
        return i;
      }
      function whitespace() {
        if (/[^\s]/g.test(c)) {
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function preprocessor() {
        if ((c === "\r" || c === "\n") && last !== "\\") {
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function line_comment() {
        return preprocessor();
      }
      function block_comment() {
        if (c === "/" && last === "*") {
          content.push(c);
          token(content.join(""));
          mode = NORMAL;
          return i + 1;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function operator() {
        if (last === "." && /\d/.test(c)) {
          mode = FLOAT;
          return i;
        }
        if (last === "/" && c === "*") {
          mode = BLOCK_COMMENT;
          return i;
        }
        if (last === "/" && c === "/") {
          mode = LINE_COMMENT;
          return i;
        }
        if (c === "." && content.length) {
          while (determine_operator(content)) ;
          mode = FLOAT;
          return i;
        }
        if (c === ";" || c === ")" || c === "(") {
          if (content.length) while (determine_operator(content)) ;
          token(c);
          mode = NORMAL;
          return i + 1;
        }
        var is_composite_operator = content.length === 2 && c !== "=";
        if (/[\w_\d\s]/.test(c) || is_composite_operator) {
          while (determine_operator(content)) ;
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function determine_operator(buf) {
        var j3 = 0, idx, res;
        do {
          idx = operators.indexOf(buf.slice(0, buf.length + j3).join(""));
          res = operators[idx];
          if (idx === -1) {
            if (j3-- + buf.length > 0) continue;
            res = buf.slice(0, 1).join("");
          }
          token(res);
          start += res.length;
          content = content.slice(res.length);
          return content.length;
        } while (1);
      }
      function hex() {
        if (/[^a-fA-F0-9]/.test(c)) {
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function integer() {
        if (c === ".") {
          content.push(c);
          mode = FLOAT;
          last = c;
          return i + 1;
        }
        if (/[eE]/.test(c)) {
          content.push(c);
          mode = FLOAT;
          last = c;
          return i + 1;
        }
        if (c === "x" && content.length === 1 && content[0] === "0") {
          mode = HEX;
          content.push(c);
          last = c;
          return i + 1;
        }
        if (/[^\d]/.test(c)) {
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function decimal() {
        if (c === "f") {
          content.push(c);
          last = c;
          i += 1;
        }
        if (/[eE]/.test(c)) {
          content.push(c);
          last = c;
          return i + 1;
        }
        if ((c === "-" || c === "+") && /[eE]/.test(last)) {
          content.push(c);
          last = c;
          return i + 1;
        }
        if (/[^\d]/.test(c)) {
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function readtoken() {
        if (/[^\d\w_]/.test(c)) {
          var contentstr = content.join("");
          if (literalsDict[contentstr]) {
            mode = KEYWORD;
          } else if (builtinsDict[contentstr]) {
            mode = BUILTIN;
          } else {
            mode = IDENT;
          }
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
    }
  }
});

// node_modules/glsl-tokenizer/string.js
var require_string = __commonJS({
  "node_modules/glsl-tokenizer/string.js"(exports, module) {
    var tokenize = require_glsl_tokenizer();
    module.exports = tokenizeString;
    function tokenizeString(str, opt) {
      var generator = tokenize(opt);
      var tokens = [];
      tokens = tokens.concat(generator(str));
      tokens = tokens.concat(generator(null));
      return tokens;
    }
  }
});

// node_modules/glsl-token-depth/index.js
var require_glsl_token_depth = __commonJS({
  "node_modules/glsl-token-depth/index.js"(exports, module) {
    module.exports = getTokenDepth;
    function getTokenDepth(tokens) {
      var loop = false;
      var depth = 0;
      for (var i = 0; i < tokens.length; i++) {
        loop = loop || tokens[i].type === "keyword" && tokens[i].data === "for";
        switch (tokens[i].data) {
          case "(":
            tokens[i].depth = loop ? depth++ : depth;
            break;
          case "{":
            tokens[i].depth = loop ? depth : depth++;
            loop = false;
            break;
          case "}":
            tokens[i].depth = --depth;
            break;
          default:
            tokens[i].depth = depth;
        }
      }
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        var index = i + 1;
        if (token.type !== "ident" && token.type !== "keyword") continue;
        skipArrayArguments();
        if (tokens[index].type !== "ident") continue;
        skipArrayArguments();
        index++;
        if (tokens[index].data !== "(") continue;
        while (tokens[index] && tokens[index].data !== ";" && tokens[index].data !== "{") {
          tokens[index++].depth++;
        }
        if (tokens[index] && tokens[index].data === "{") tokens[index].depth++;
      }
      return tokens;
      function skipArrayArguments() {
        while (tokens[index] && (tokens[index].type === "whitespace" || tokens[index].data === "[" || tokens[index].data === "]" || tokens[index].data === "integer")) index++;
      }
    }
  }
});

// node_modules/glsl-token-scope/index.js
var require_glsl_token_scope = __commonJS({
  "node_modules/glsl-token-scope/index.js"(exports, module) {
    module.exports = tokenScope;
    function tokenScope(tokens) {
      var stack = [0];
      var inc = stack[0];
      var ldepth = 0;
      if (!tokens || !tokens.length) return tokens;
      if (!("depth" in tokens[0])) {
        throw new Error("glsl-token-scope: No scope depth defined on tokens! Use glsl-token-depth on these tokens first");
      }
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        var depth = token.depth;
        if (depth > ldepth) {
          stack.push(++inc);
        } else if (depth < ldepth) {
          stack.splice(-1, 1);
        }
        token.scope = stack[stack.length - 1];
        token.stack = stack.slice();
        ldepth = token.depth;
      }
      return tokens;
    }
  }
});

// node_modules/glsl-token-properties/index.js
var require_glsl_token_properties = __commonJS({
  "node_modules/glsl-token-properties/index.js"(exports, module) {
    module.exports = properties;
    function properties(tokens) {
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        token.property = false;
        if (token.type !== "ident") continue;
        var j3 = i;
        while (tokens[--j3] && tokens[j3].type === "whitespace") ;
        if (!tokens[j3]) continue;
        if (tokens[j3].type !== "operator") continue;
        if (tokens[j3].data !== ".") continue;
        token.property = true;
      }
      return tokens;
    }
  }
});

// node_modules/glsl-token-assignments/assignments.js
var require_assignments = __commonJS({
  "node_modules/glsl-token-assignments/assignments.js"(exports, module) {
    module.exports = {
      "<<=": true,
      ">>=": true,
      "++": true,
      "--": true,
      "+=": true,
      "-=": true,
      "*=": true,
      "/=": true,
      "%=": true,
      "&=": true,
      "^=": true,
      "|=": true,
      "=": true
    };
  }
});

// node_modules/glsl-token-assignments/ignored.js
var require_ignored = __commonJS({
  "node_modules/glsl-token-assignments/ignored.js"(exports, module) {
    module.exports = {
      "precision": true,
      "highp": true,
      "mediump": true,
      "lowp": true,
      "attribute": true,
      "const": true,
      "uniform": true,
      "varying": true,
      "break": true,
      "continue": true,
      "do": true,
      "for": true,
      "while": true,
      "if": true,
      "else": true,
      "in": true,
      "out": true,
      "inout": true,
      "true": true,
      "false": true,
      "return": true
    };
  }
});

// node_modules/glsl-token-assignments/index.js
var require_glsl_token_assignments = __commonJS({
  "node_modules/glsl-token-assignments/index.js"(exports, module) {
    var assignments = require_assignments();
    var ignoredKeywords = require_ignored();
    module.exports = assigns;
    function assigns(tokens) {
      var idx = 0;
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        var type = token.type;
        token.assignment = false;
        token.declaration = false;
        if (type !== "ident" && type !== "builtin") continue;
        idx = i + 1;
        skipWhitespace(1);
        if (tokens[idx].type !== "operator") continue;
        if (!assignments[tokens[idx].data]) continue;
        token.assignment = true;
      }
      for (var i = 0; i < tokens.length; i++) {
        var datatype = tokens[i];
        var type = datatype.type;
        var data = datatype.data;
        datatype.declaration = false;
        if (type === "keyword") {
          if (ignoredKeywords[data]) continue;
        } else if (type !== "ident") continue;
        idx = i + 1;
        skipArrayDimensions();
        if (tokens[idx].type !== "ident") continue;
        tokens[idx++].declaration = true;
        skipArrayDimensions();
        if (tokens[idx].data === "(") {
          idx++;
          skipWhitespace(1);
          while (tokens[idx] && tokens[idx].data !== ")") {
            if (tokens[idx].type !== "keyword" && tokens[idx].type !== "ident") break;
            idx++;
            skipWhitespace(1);
            if (tokens[idx].type !== "ident") continue;
            tokens[idx++].declaration = true;
            skipWhitespace(1);
            skipArrayDimensions();
            skipWhitespace(1);
            if (tokens[idx].data !== ",") continue;
            idx++;
            skipWhitespace(1);
          }
          i = idx;
          continue;
        }
        while (tokens[idx] && tokens[idx].data !== ";") {
          if (tokens[idx].data === ",") {
            idx++;
            skipWhitespace(1);
            if (tokens[idx].declaration = tokens[idx].type === "ident") idx++;
          } else {
            skipWhitespace(1);
            skipParens();
            skipWhitespace(1);
            idx++;
          }
        }
        i = idx;
      }
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        if (token.type !== "keyword") continue;
        if (token.data !== "struct") continue;
        idx = i + 1;
        skipWhitespace(1);
        if (tokens[idx].type !== "ident") continue;
        idx++;
        skipWhitespace(1);
        if (tokens[idx++].data !== "{") continue;
        skipWhitespace(1);
        while (tokens[idx].type === "ident" || tokens[idx].type === "keyword") {
          do {
            idx++;
            skipWhitespace(1);
            tokens[idx].structMember = true;
            tokens[idx].declaration = false;
            idx++;
            skipArrayDimensions();
          } while (tokens[idx].data === ",");
          if (tokens[idx].data === ";") idx++;
          skipWhitespace();
        }
        idx++;
        skipWhitespace(1);
        if (tokens[idx].type !== "ident") continue;
        tokens[idx].declaration = true;
        skipWhitespace(1);
        while (tokens[++idx].data === ",") {
          skipWhitespace(1);
          idx++;
          skipWhitespace(1);
          if (tokens[idx].type === "ident") tokens[idx].declaration = true;
          skipWhitespace(1);
        }
      }
      return tokens;
      function skipWhitespace(n) {
        while (tokens[idx] && tokens[idx].type === "whitespace") idx++;
      }
      function skipArrayDimensions() {
        while (tokens[idx] && (tokens[idx].type === "integer" || tokens[idx].data === "[" || tokens[idx].data === "]" || tokens[idx].type === "whitespace")) idx++;
      }
      function skipParens() {
        if (!tokens[idx]) return;
        if (tokens[idx].data !== "(") return;
        var depth = 0;
        var a = idx;
        do {
          if (tokens[idx].data === ";") break;
          if (tokens[idx].data === "(") depth++;
          if (tokens[idx].data === ")") depth--;
        } while (depth && tokens[++idx]);
      }
    }
  }
});

// node_modules/glsl-token-descope/index.js
var require_glsl_token_descope = __commonJS({
  "node_modules/glsl-token-descope/index.js"(exports, module) {
    module.exports = glslTokenDescope;
    function glslTokenDescope(tokens, rename) {
      require_glsl_token_depth()(tokens);
      require_glsl_token_scope()(tokens);
      require_glsl_token_properties()(tokens);
      require_glsl_token_assignments()(tokens);
      var scope = getScope(tokens);
      var renamer = rename || defaultRenamer();
      var map = {};
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        var stack = token.stack;
        var name = token.data;
        token.descoped = false;
        if (token.type !== "ident") continue;
        if (token.property) continue;
        if (token.structMember) continue;
        var bound = false;
        for (var j3 = stack.length - 1; j3 >= 0; j3--) {
          var s3 = scope[stack[j3]];
          if (!s3) continue;
          if (!s3[name]) continue;
          bound = true;
          if (j3) break;
          token.descoped = token.data;
          token.data = map[name] = map[name] || renamer(name, token) || token.data;
        }
        if (!bound) {
          token.descoped = token.data;
          token.data = map[name] = map[name] || renamer(name, token) || token.data;
        }
      }
      return tokens;
    }
    function defaultRenamer() {
      var k3 = 0;
      return function rename(name) {
        return name + "_" + (k3++).toString(36);
      };
    }
    function getScope(tokens) {
      var scope = {};
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        if (token.declaration) {
          scope[token.scope] = scope[token.scope] || {};
          scope[token.scope][token.data] = token;
        }
      }
      return scope;
    }
  }
});

// node_modules/glsl-token-string/index.js
var require_glsl_token_string = __commonJS({
  "node_modules/glsl-token-string/index.js"(exports, module) {
    module.exports = toString;
    function toString(tokens) {
      var output = [];
      for (var i = 0; i < tokens.length; i++) {
        if (tokens[i].type === "eof") continue;
        output.push(tokens[i].data);
      }
      return output.join("");
    }
  }
});

// node_modules/glsl-token-functions/index.js
var require_glsl_token_functions = __commonJS({
  "node_modules/glsl-token-functions/index.js"(exports, module) {
    module.exports = functions;
    function functions(tokens) {
      var returnType = null;
      var defnName = null;
      var braceDepth = 0;
      var braceStart = 0;
      var defnStart = 0;
      var argFinish = 0;
      var argStart = 0;
      var output = [];
      var i, j3, token;
      for (i = 0, j3; i < tokens.length; i++) {
        token = tokens[i];
        if (token.data === "{") {
          if (braceDepth && braceDepth++) continue;
          j3 = findPrevious(i, findOp(")"), findOp());
          if (j3 < 0) continue;
          argFinish = j3;
          j3 = findPrevious(j3, findOp("("), findOp(")"));
          if (j3 < 0) continue;
          argStart = j3;
          j3 = findPrevious(j3, findGlyph);
          if (j3 < 0) continue;
          if (tokens[j3].type !== "ident") continue;
          defnName = tokens[j3].data;
          j3 = findPrevious(j3, findGlyph);
          if (j3 < 0) continue;
          braceDepth = 1;
          braceStart = i;
          returnType = tokens[j3].data;
          defnStart = j3;
          var k3 = findPrevious(j3, findGlyph);
          switch (tokens[k3] && tokens[k3].data) {
            case "lowp":
            case "highp":
            case "mediump":
              defnStart = k3;
          }
        } else if (braceDepth && token.data === "}") {
          if (--braceDepth) continue;
          output.push({
            name: defnName,
            type: returnType,
            body: [braceStart + 1, i],
            args: [argStart, argFinish + 1],
            outer: [defnStart, i + 1]
          });
        }
      }
      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        if (token.data === ";") {
          j3 = findPrevious(i, findOp(")"), findOp());
          if (j3 < 0) continue;
          argFinish = j3;
          j3 = findPrevious(j3, findOp("("), findOp(")"));
          if (j3 < 0) continue;
          argStart = j3;
          j3 = findPrevious(j3, findGlyph);
          if (j3 < 0) continue;
          if (tokens[j3].type !== "ident") continue;
          defnName = tokens[j3].data;
          j3 = findPrevious(j3, findGlyph);
          if (j3 < 0) continue;
          if (tokens[j3].type === "operator") continue;
          if (tokens[j3].data === "return") continue;
          returnType = tokens[j3].data;
          output.push({
            name: defnName,
            type: returnType,
            body: false,
            args: [argStart, argFinish + 1],
            outer: [j3, i + 1]
          });
        }
      }
      return output.sort(function(a, b2) {
        return a.outer[0] - b2.outer[0];
      });
      function findPrevious(start, match, bail) {
        for (var i2 = start - 1; i2 >= 0; i2--) {
          if (match(tokens[i2])) return i2;
          if (bail && bail(tokens[i2])) return -1;
        }
        return -1;
      }
    }
    function findOp(data) {
      return function(token) {
        return token.type === "operator" && (!data || token.data === data);
      };
    }
    function findGlyph(token) {
      return token.type !== "whitespace";
    }
  }
});

// node_modules/three-custom-shader-material/vanilla/three-custom-shader-material.es.js
var D = (
  /* glsl */
  `
    
#ifdef IS_VERTEX
    vec3 csm_Position;
    vec4 csm_PositionRaw;
    vec3 csm_Normal;

    // csm_PointSize
    #ifdef IS_POINTSMATERIAL
        float csm_PointSize;
    #endif
#else
    vec4 csm_DiffuseColor;
    vec4 csm_FragColor;
    float csm_UnlitFac;

    // csm_Emissive, csm_Roughness, csm_Metalness
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL
        vec3 csm_Emissive;
        float csm_Roughness;
        float csm_Metalness;
        float csm_Iridescence;
        
        #if defined IS_MESHPHYSICALMATERIAL
            float csm_Clearcoat;
            float csm_ClearcoatRoughness;
            vec3 csm_ClearcoatNormal;
            float csm_Transmission;
            float csm_Thickness;
        #endif
    #endif

    // csm_AO
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL
        float csm_AO;
    #endif

    // csm_FragNormal
    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL 
        vec3 csm_FragNormal;
    #endif

    float csm_DepthAlpha;
#endif
`
);
var H = (
  /* glsl */
  `

#ifdef IS_VERTEX
    // csm_Position & csm_PositionRaw
    #ifdef IS_UNKNOWN
        csm_Position = vec3(0.0);
        csm_PositionRaw = vec4(0.0);
        csm_Normal = vec3(0.0);
    #else
        csm_Position = position;
        csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);
        csm_Normal = normal;
    #endif

    // csm_PointSize
    #ifdef IS_POINTSMATERIAL
        csm_PointSize = size;
    #endif
#else
    csm_UnlitFac = 0.0;

    // csm_DiffuseColor & csm_FragColor
    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHDISTANCEMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL
        csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);
        csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #else
        #ifdef USE_MAP
            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);

            #ifdef DECODE_VIDEO_TEXTURE
            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)
            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);
            #endif

            csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
            csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
        #else
            csm_DiffuseColor = vec4(diffuse, opacity);
            csm_FragColor = vec4(diffuse, opacity);
        #endif
    #endif

    // csm_Emissive, csm_Roughness, csm_Metalness
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL
        csm_Emissive = emissive;
        csm_Roughness = roughness;
        csm_Metalness = metalness;

        #ifdef USE_IRIDESCENCE
            csm_Iridescence = iridescence;
        #else
            csm_Iridescence = 0.0;
        #endif

        #if defined IS_MESHPHYSICALMATERIAL
            #ifdef USE_CLEARCOAT
                csm_Clearcoat = clearcoat;
                csm_ClearcoatRoughness = clearcoatRoughness;
            #else
                csm_Clearcoat = 0.0;
                csm_ClearcoatRoughness = 0.0;
            #endif

            #ifdef USE_TRANSMISSION
                csm_Transmission = transmission;
                csm_Thickness = thickness;
            #else
                csm_Transmission = 0.0;
                csm_Thickness = 0.0;
            #endif
        #endif
    #endif

    // csm_AO
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL
        csm_AO = 0.0;
    #endif

    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL 
        #ifdef FLAT_SHADED
            vec3 fdx = dFdx( vViewPosition );
            vec3 fdy = dFdy( vViewPosition );
            csm_FragNormal = normalize( cross( fdx, fdy ) );
        #else
            csm_FragNormal = normalize(vNormal);
            #ifdef DOUBLE_SIDED
                csm_FragNormal *= gl_FrontFacing ? 1.0 : - 1.0;
            #endif
        #endif
    #endif

    csm_DepthAlpha = 1.0;
#endif
`
);
var y = (
  /* glsl */
  `
    varying mat4 csm_internal_vModelViewMatrix;
`
);
var O = (
  /* glsl */
  `
    csm_internal_vModelViewMatrix = modelViewMatrix;
`
);
var x = (
  /* glsl */
  `
    varying mat4 csm_internal_vModelViewMatrix;
`
);
var F = (
  /* glsl */
  `
    
`
);
var e = {
  // PBR (frag)
  diffuse: "csm_DiffuseColor",
  // Color + alpha
  roughness: "csm_Roughness",
  // Roughness
  metalness: "csm_Metalness",
  // Metalness
  emissive: "csm_Emissive",
  // Emissive
  ao: "csm_AO",
  // AO
  fragNormal: "csm_FragNormal",
  // Fragment Normal
  clearcoat: "csm_Clearcoat",
  // Clearcoat factor
  clearcoatRoughness: "csm_ClearcoatRoughness",
  // Clearcoat roughness
  clearcoatNormal: "csm_ClearcoatNormal",
  // Clearcoat normals
  transmission: "csm_Transmission",
  // Transmission
  thickness: "csm_Thickness",
  // Thickness
  iridescence: "csm_Iridescence",
  // Iridescence
  // Extras
  pointSize: "csm_PointSize",
  // gl_PointSize (Frag)
  fragColor: "csm_FragColor",
  // gl_FragColor (Frag)
  depthAlpha: "csm_DepthAlpha",
  // Depth (MeshDepthMaterial)
  unlitFac: "csm_UnlitFac",
  // Unlit factor (mix between csm_FragColor and csm_DiffuseColor)
  // Vert
  position: "csm_Position",
  // gl_Position
  positionRaw: "csm_PositionRaw",
  // gl_Position (without projection)
  normal: "csm_Normal"
  // Vertex Normal
};
var b = {
  [`${e.position}`]: "*",
  [`${e.positionRaw}`]: "*",
  [`${e.normal}`]: "*",
  [`${e.depthAlpha}`]: "*",
  [`${e.pointSize}`]: ["PointsMaterial"],
  [`${e.diffuse}`]: "*",
  [`${e.fragColor}`]: "*",
  [`${e.fragNormal}`]: "*",
  [`${e.unlitFac}`]: "*",
  [`${e.emissive}`]: ["MeshStandardMaterial", "MeshPhysicalMaterial"],
  [`${e.roughness}`]: ["MeshStandardMaterial", "MeshPhysicalMaterial"],
  [`${e.metalness}`]: ["MeshStandardMaterial", "MeshPhysicalMaterial"],
  [`${e.iridescence}`]: [
    "MeshStandardMaterial",
    "MeshPhysicalMaterial"
  ],
  [`${e.ao}`]: [
    "MeshStandardMaterial",
    "MeshPhysicalMaterial",
    "MeshBasicMaterial",
    "MeshLambertMaterial",
    "MeshPhongMaterial",
    "MeshToonMaterial"
  ],
  [`${e.clearcoat}`]: ["MeshPhysicalMaterial"],
  [`${e.clearcoatRoughness}`]: ["MeshPhysicalMaterial"],
  [`${e.clearcoatNormal}`]: ["MeshPhysicalMaterial"],
  [`${e.transmission}`]: ["MeshPhysicalMaterial"],
  [`${e.thickness}`]: ["MeshPhysicalMaterial"]
};
var k = {
  // VERT
  "*": {
    "#include <lights_physical_fragment>": ShaderChunk.lights_physical_fragment,
    "#include <transmission_fragment>": ShaderChunk.transmission_fragment
  },
  [`${e.normal}`]: {
    "#include <beginnormal_vertex>": `
    vec3 objectNormal = ${e.normal};
    #ifdef USE_TANGENT
	    vec3 objectTangent = vec3( tangent.xyz );
    #endif
    `
  },
  [`${e.position}`]: {
    "#include <begin_vertex>": `
    vec3 transformed = ${e.position};
  `
  },
  [`${e.positionRaw}`]: {
    "#include <project_vertex>": `
    #include <project_vertex>
    gl_Position = ${e.positionRaw};
  `
  },
  [`${e.pointSize}`]: {
    "gl_PointSize = size;": `
    gl_PointSize = ${e.pointSize};
    `
  },
  // FRAG
  [`${e.diffuse}`]: {
    "#include <color_fragment>": `
    #include <color_fragment>
    diffuseColor = ${e.diffuse};
  `
  },
  [`${e.fragColor}`]: {
    "#include <opaque_fragment>": `
    #include <opaque_fragment>
    gl_FragColor = mix(gl_FragColor, ${e.fragColor}, ${e.unlitFac});
  `
  },
  [`${e.emissive}`]: {
    "vec3 totalEmissiveRadiance = emissive;": `
    vec3 totalEmissiveRadiance = ${e.emissive};
    `
  },
  [`${e.roughness}`]: {
    "#include <roughnessmap_fragment>": `
    #include <roughnessmap_fragment>
    roughnessFactor = ${e.roughness};
    `
  },
  [`${e.metalness}`]: {
    "#include <metalnessmap_fragment>": `
    #include <metalnessmap_fragment>
    metalnessFactor = ${e.metalness};
    `
  },
  [`${e.ao}`]: {
    "#include <aomap_fragment>": `
    #include <aomap_fragment>
    reflectedLight.indirectDiffuse *= 1. - ${e.ao};
    `
  },
  [`${e.fragNormal}`]: {
    "#include <normal_fragment_maps>": `
      #include <normal_fragment_maps>
      normal = ${e.fragNormal};
    `
  },
  [`${e.depthAlpha}`]: {
    "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );": `
      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * 1.0 - ${e.depthAlpha} );
    `,
    "gl_FragColor = packDepthToRGBA( fragCoordZ );": `
      if(${e.depthAlpha} < 1.0) discard;
      gl_FragColor = packDepthToRGBA( dist );
    `,
    "gl_FragColor = packDepthToRGBA( dist );": `
      if(${e.depthAlpha} < 1.0) discard;
      gl_FragColor = packDepthToRGBA( dist );
    `
  },
  [`${e.clearcoat}`]: {
    "material.clearcoat = clearcoat;": `material.clearcoat = ${e.clearcoat};`
  },
  [`${e.clearcoatRoughness}`]: {
    "material.clearcoatRoughness = clearcoatRoughness;": `material.clearcoatRoughness = ${e.clearcoatRoughness};`
  },
  [`${e.clearcoatNormal}`]: {
    "#include <clearcoat_normal_fragment_begin>": `
      vec3 csm_coat_internal_orthogonal = csm_ClearcoatNormal - (dot(csm_ClearcoatNormal, nonPerturbedNormal) * nonPerturbedNormal);
      vec3 csm_coat_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_coat_internal_orthogonal;
      vec3 clearcoatNormal = normalize(nonPerturbedNormal - csm_coat_internal_projectedbump);
    `
  },
  [`${e.transmission}`]: {
    "material.transmission = transmission;": `
      material.transmission = ${e.transmission};
    `
  },
  [`${e.thickness}`]: {
    "material.thickness = thickness;": `
      material.thickness = ${e.thickness};
    `
  },
  [`${e.iridescence}`]: {
    "material.iridescence = iridescence;": `
      material.iridescence = ${e.iridescence};
    `
  }
};
var w = {
  clearcoat: [
    e.clearcoat,
    e.clearcoatNormal,
    e.clearcoatRoughness
  ],
  transmission: [e.transmission],
  iridescence: [e.iridescence]
};
function U(u3) {
  let a = 0;
  for (let m = 0; m < u3.length; m++)
    a = u3.charCodeAt(m) + (a << 6) + (a << 16) - a;
  const _3 = a >>> 0;
  return String(_3);
}
function z(u3) {
  try {
    new u3();
  } catch (a) {
    if (a.message.indexOf("is not a constructor") >= 0)
      return false;
  }
  return true;
}
function P(u3) {
  return u3.replace(/\/\*[\s\S]*?\*\/|\/\/.*/g, "");
}
var j = class extends Material {
  constructor({
    baseMaterial: a,
    vertexShader: _3,
    fragmentShader: A2,
    uniforms: m,
    patchMap: p3,
    cacheKey: S2,
    ...d3
  }) {
    if (!a)
      throw new Error("CustomShaderMaterial: baseMaterial is required.");
    let i;
    if (z(a)) {
      const t = Object.keys(d3).length === 0;
      i = new a(t ? void 0 : d3);
    } else
      i = a, Object.assign(i, d3);
    if (["ShaderMaterial", "RawShaderMaterial"].includes(i.type))
      throw new Error(
        `CustomShaderMaterial does not support ${i.type} as a base material.`
      );
    super(), this.uniforms = {}, this.vertexShader = "", this.fragmentShader = "";
    const o = i;
    o.name = `CustomShaderMaterial<${i.name || i.type}>`, o.update = this.update, o.__csm = {
      prevOnBeforeCompile: i.onBeforeCompile,
      baseMaterial: i,
      vertexShader: _3,
      fragmentShader: A2,
      uniforms: m,
      patchMap: p3,
      cacheKey: S2
    };
    const n = { ...o.uniforms || {}, ...m || {} };
    o.uniforms = this.uniforms = n, o.vertexShader = this.vertexShader = _3 || "", o.fragmentShader = this.fragmentShader = A2 || "", o.update({
      fragmentShader: o.fragmentShader,
      vertexShader: o.vertexShader,
      uniforms: o.uniforms,
      patchMap: p3,
      cacheKey: S2
    }), Object.assign(this, o);
    const f = Object.getOwnPropertyDescriptors(
      Object.getPrototypeOf(o)
    );
    for (const t in f) {
      const l = f[t];
      (l.get || l.set) && Object.defineProperty(this, t, l);
    }
    return Object.defineProperty(this, "type", {
      get() {
        return i.type;
      },
      set(t) {
        i.type = t;
      }
    }), this;
  }
  update({
    fragmentShader: a,
    vertexShader: _3,
    uniforms: A2,
    cacheKey: m,
    patchMap: p3
  }) {
    const S2 = P(_3 || ""), d3 = P(a || ""), i = this;
    A2 && (i.uniforms = A2), _3 && (i.vertexShader = _3), a && (i.fragmentShader = a), Object.entries(w).forEach(([s3, n]) => {
      for (const f in n) {
        const t = n[f];
        (d3 && d3.includes(t) || S2 && S2.includes(t)) && (i[s3] || (i[s3] = 1));
      }
    });
    const R2 = i.__csm.prevOnBeforeCompile, o = (s3, n, f) => {
      let t, l = "";
      if (n) {
        const r = n.search(/void\s+main\s*\(\s*\)\s*{/);
        if (r !== -1) {
          l = n.slice(0, r);
          let c = 0, g3 = -1;
          for (let M2 = r; M2 < n.length; M2++)
            if (n[M2] === "{" && c++, n[M2] === "}" && (c--, c === 0)) {
              g3 = M2;
              break;
            }
          if (g3 !== -1) {
            const M2 = n.slice(r, g3 + 1);
            t = M2.slice(M2.indexOf("{") + 1, -1);
          }
        } else
          l = n;
      }
      if (f && (n && n.includes(e.fragColor)) && t && (t = `csm_UnlitFac = 1.0;
` + t), s3.includes("//~CSM_DEFAULTS")) {
        s3 = s3.replace(
          "void main() {",
          `
          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial
  
          ${l}
          
          void main() {
          `
        );
        const r = s3.lastIndexOf("//~CSM_MAIN_END");
        if (r !== -1) {
          const c = `
            ${t ? `${t}` : ""}
            //~CSM_MAIN_END
          `;
          s3 = s3.slice(0, r) + c + s3.slice(r);
        }
      } else {
        const r = /void\s*main\s*\(\s*\)\s*{/gm;
        s3 = s3.replace(
          r,
          `
          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial
  
          //~CSM_DEFAULTS
          ${f ? x : y}
          ${D}
  
          ${l}
          
          void main() {
            {
              ${H}
            }
            ${f ? F : O}

            ${t ? `${t}` : ""}
            //~CSM_MAIN_END
          `
        );
      }
      return s3;
    };
    i.onBeforeCompile = (s3, n) => {
      R2 == null || R2(s3, n);
      const f = p3 || {}, t = i.type, l = t ? `#define IS_${t.toUpperCase()};
` : `#define IS_UNKNOWN;
`;
      s3.vertexShader = l + `#define IS_VERTEX
` + s3.vertexShader, s3.fragmentShader = l + `#define IS_FRAGMENT
` + s3.fragmentShader;
      const T2 = (r) => {
        for (const c in r) {
          const g3 = c === "*" || S2 && S2.includes(c);
          if (c === "*" || d3 && d3.includes(c) || g3) {
            const E2 = b[c];
            if (E2 && E2 !== "*" && (Array.isArray(E2) ? !E2.includes(t) : E2 !== t)) {
              console.error(
                `CustomShaderMaterial: ${c} is not available in ${t}. Shader cannot compile.`
              );
              return;
            }
            const $2 = r[c];
            for (const I2 in $2) {
              const h3 = $2[I2];
              if (typeof h3 == "object") {
                const N2 = h3.type, L2 = h3.value;
                N2 === "fs" ? s3.fragmentShader = s3.fragmentShader.replace(
                  I2,
                  L2
                ) : N2 === "vs" && (s3.vertexShader = s3.vertexShader.replace(
                  I2,
                  L2
                ));
              } else h3 && (s3.vertexShader = s3.vertexShader.replace(
                I2,
                h3
              ), s3.fragmentShader = s3.fragmentShader.replace(
                I2,
                h3
              ));
            }
          }
        }
      };
      T2(k), T2(f), s3.vertexShader = o(
        s3.vertexShader,
        S2,
        false
      ), s3.fragmentShader = o(
        s3.fragmentShader,
        d3,
        true
      ), A2 && (s3.uniforms = { ...s3.uniforms, ...i.uniforms }), i.uniforms = s3.uniforms;
    };
    const C2 = i.customProgramCacheKey;
    i.customProgramCacheKey = () => ((m == null ? void 0 : m()) || U((S2 || "") + (d3 || ""))) + (C2 == null ? void 0 : C2.call(i)), i.needsUpdate = true;
  }
  clone() {
    const a = this;
    return new a.constructor({
      baseMaterial: a.__csm.baseMaterial.clone(),
      vertexShader: a.__csm.vertexShader,
      fragmentShader: a.__csm.fragmentShader,
      uniforms: a.__csm.uniforms,
      patchMap: a.__csm.patchMap,
      cacheKey: a.__csm.cacheKey
    });
  }
};

// node_modules/lamina/vanilla-BEVDQrzM.js
var import_glsl_tokenizer = __toESM(require_string(), 1);
var import_glsl_token_descope = __toESM(require_glsl_token_descope(), 1);
var import_glsl_token_string = __toESM(require_glsl_token_string(), 1);
var import_glsl_token_functions = __toESM(require_glsl_token_functions(), 1);
var ee = {
  normal: "normal",
  add: "add",
  subtract: "subtract",
  multiply: "multiply",
  lighten: "lighten",
  darken: "darken",
  divide: "divide",
  overlay: "overlay",
  screen: "screen",
  softlight: "softlight",
  negation: "negation",
  reflect: "reflect"
};
var R = {
  perlin: "perlin",
  simplex: "simplex",
  cell: "cell",
  curl: "curl",
  white: "white"
};
var k2 = {
  local: "local",
  world: "world",
  uv: "uv"
};
var ae = {
  phong: MeshPhongMaterial,
  physical: MeshPhysicalMaterial,
  toon: MeshToonMaterial,
  basic: MeshBasicMaterial,
  lambert: MeshLambertMaterial,
  standard: MeshStandardMaterial
};
function q(r) {
  return typeof r == "string" ? new Color(r).convertLinearToSRGB() : r;
}
function te(r) {
  switch (r) {
    case "alpha":
      return {
        min: 0,
        max: 1
      };
    case "scale":
      return {
        min: 0
      };
    case "map":
      return {
        image: void 0
      };
    default:
      return {};
  }
}
function ve({ color: r, alpha: a, lighting: e2, name: t, ...n } = {}) {
  return [
    {
      color: r,
      alpha: a,
      lighting: e2,
      name: t
    },
    n
  ];
}
function E(r) {
  return r instanceof Vector3 || r instanceof Vector2 || r instanceof Vector4 || r instanceof Matrix3 || r instanceof Matrix4;
}
function I(r) {
  return E(r) ? r.toArray() : r instanceof Color ? "#" + r.clone().convertLinearToSRGB().getHexString() : r instanceof Texture ? r.image.src : r;
}
var x2 = class {
  constructor(a, e2, t) {
    this.uuid = MathUtils.generateUUID().replace(/-/g, "_"), this.name = "LayerMaterial", this.mode = "normal", this.visible = true;
    const i = Object.getOwnPropertyNames(a).filter((c) => c.startsWith("u_")).reduce((c, l) => {
      var m;
      let f = (m = Object.getOwnPropertyDescriptor(a, l)) == null ? void 0 : m.value;
      return (E(f) || f instanceof Color) && (f = f.clone()), {
        ...c,
        [l.slice(1)]: f
      };
    }, {});
    for (const c in i) {
      const l = c.split("_")[1];
      (e2 == null ? void 0 : e2[l]) !== void 0 && (i[c] = e2[l]);
    }
    e2 && Object.keys(e2).map((c) => {
      e2[c] !== void 0 && (this[c] = e2[c]);
    }), this.uniforms = {}, this.schema = [];
    const o = {};
    Object.keys(i).map((c) => {
      const l = c.split("_")[1];
      this.uniforms[`u_${this.uuid}_${l}`] = {
        value: q(i[c])
      }, this.schema.push({
        value: i[c],
        label: l
      }), o[l] = {
        set: (f) => {
          this.uniforms[`u_${this.uuid}_${l}`].value = q(f);
        },
        get: () => this.uniforms[`u_${this.uuid}_${l}`].value
      };
    }), e2 != null && e2.name && (this.name = e2.name), e2 != null && e2.mode && (this.mode = e2.mode), e2 != null && e2.visible && (this.visible = e2.visible), Object.defineProperties(this, o), this.vertexShader = "", this.fragmentShader = "", this.vertexVariables = "", this.fragmentVariables = "", this.onParse = t, this.buildShaders(a), this.schema.push({
      value: this.mode,
      label: "mode",
      options: Object.values(ee)
    }), this.schema.push({
      value: this.visible,
      label: "visible"
    });
  }
  buildShaders(a) {
    var f;
    const e2 = Object.getOwnPropertyNames(a).filter((m) => m === "fragmentShader" || m === "vertexShader").reduce(
      (m, w2) => {
        var P2;
        return {
          ...m,
          [w2]: (P2 = Object.getOwnPropertyDescriptor(a, w2)) == null ? void 0 : P2.value
        };
      },
      {}
    ), t = {
      vert: (0, import_glsl_tokenizer.default)(e2.vertexShader || ""),
      frag: (0, import_glsl_tokenizer.default)(e2.fragmentShader || "")
    }, n = {
      vert: (0, import_glsl_token_descope.default)(t.vert, this.renameTokens.bind(this)),
      frag: (0, import_glsl_token_descope.default)(t.frag, this.renameTokens.bind(this))
    }, i = {
      vert: (0, import_glsl_token_functions.default)(n.vert),
      frag: (0, import_glsl_token_functions.default)(n.frag)
    }, o = {
      vert: i.vert.map((m) => m.name).indexOf("main"),
      frag: i.frag.map((m) => m.name).indexOf("main")
    }, c = {
      vert: o.vert >= 0 ? (0, import_glsl_token_string.default)(n.vert.slice(0, i.vert[o.vert].outer[0])) : "",
      frag: o.frag >= 0 ? (0, import_glsl_token_string.default)(n.frag.slice(0, i.frag[o.frag].outer[0])) : ""
    }, l = {
      vert: o.vert >= 0 ? this.getShaderFromIndex(n.vert, i.vert[o.vert].body) : "",
      frag: o.frag >= 0 ? this.getShaderFromIndex(n.frag, i.frag[o.frag].body) : ""
    };
    this.vertexShader = this.processFinal(l.vert, true), this.fragmentShader = this.processFinal(l.frag), this.vertexVariables = c.vert, this.fragmentVariables = c.frag, (f = this.onParse) == null || f.call(this, this), this.schema = this.schema.filter((m, w2) => {
      const P2 = m.label;
      return w2 === this.schema.findIndex((U2) => U2.label === P2);
    });
  }
  renameTokens(a) {
    if (a.startsWith("u_")) {
      const e2 = a.slice(2);
      return `u_${this.uuid}_${e2}`;
    } else if (a.startsWith("v_")) {
      const e2 = a.slice(2);
      return `v_${this.uuid}_${e2}`;
    } else if (a.startsWith("f_")) {
      const e2 = a.slice(2);
      return `f_${this.uuid}_${e2}`;
    } else
      return a;
  }
  processFinal(a, e2) {
    const t = a.replace(/\sf_/gm, ` f_${this.uuid}_`).replace(/\(f_/gm, `(f_${this.uuid}_`), n = t.match(/^.*return.*$/gm);
    let i = t.replace(/^.*return.*$/gm, "");
    if (n != null && n[0]) {
      const o = n[0].replace("return", "").trim().replace(";", ""), c = this.getBlendMode(o, "lamina_finalColor");
      i += e2 ? `lamina_finalPosition = ${o};` : `lamina_finalColor = ${c};`;
    }
    return i;
  }
  getShaderFromIndex(a, e2) {
    return (0, import_glsl_token_string.default)(a.slice(e2[0], e2[1]));
  }
  getBlendMode(a, e2) {
    switch (this.mode) {
      default:
      case "normal":
        return `lamina_blend_alpha(${e2}, ${a}, ${a}.a)`;
      case "add":
        return `lamina_blend_add(${e2}, ${a}, ${a}.a)`;
      case "subtract":
        return `lamina_blend_subtract(${e2}, ${a}, ${a}.a)`;
      case "multiply":
        return `lamina_blend_multiply(${e2}, ${a}, ${a}.a)`;
      case "lighten":
        return `lamina_blend_lighten(${e2}, ${a}, ${a}.a)`;
      case "darken":
        return `lamina_blend_darken(${e2}, ${a}, ${a}.a)`;
      case "divide":
        return `lamina_blend_divide(${e2}, ${a}, ${a}.a)`;
      case "overlay":
        return `lamina_blend_overlay(${e2}, ${a}, ${a}.a)`;
      case "screen":
        return `lamina_blend_screen(${e2}, ${a}, ${a}.a)`;
      case "softlight":
        return `lamina_blend_softlight(${e2}, ${a}, ${a}.a)`;
      case "reflect":
        return `lamina_blend_reflect(${e2}, ${a}, ${a}.a)`;
      case "negation":
        return `lamina_blend_negation(${e2}, ${a}, ${a}.a)`;
    }
  }
  getSchema() {
    return this.schema.map(({ label: e2, options: t, ...n }) => ({
      label: e2,
      options: t,
      ...te(e2),
      ...n,
      // @ts-ignore
      value: I(this[e2])
    }));
  }
  serialize() {
    const a = this.constructor.name.split("$")[0];
    let e2 = Object.keys(this);
    e2 = e2.filter(
      (i) => ![
        "uuid",
        "uniforms",
        "schema",
        "fragmentShader",
        "vertexShader",
        "fragmentVariables",
        "vertexVariables",
        "attribs",
        "events",
        "__r3f",
        "onParse"
      ].includes(i)
    );
    const t = {};
    e2.forEach((i) => {
      t[i] = this[i];
    });
    const n = {};
    for (const i in this.uniforms) {
      const o = i.replace(`u_${this.uuid}_`, "");
      n[o] = I(this.uniforms[i].value);
    }
    return {
      constructor: a,
      properties: {
        ...n,
        ...t
      }
    };
  }
};
var z2 = class z3 extends x2 {
  constructor(a) {
    super(z3, {
      name: "Color",
      ...a
    });
  }
};
z2.u_color = "red", z2.u_alpha = 1, z2.fragmentShader = `   
    uniform vec3 u_color;
    uniform float u_alpha;

    void main() {
      return vec4(u_color, u_alpha);
    }
  `;
var S = z2;
var v = class v2 extends x2 {
  constructor(a) {
    super(
      v2,
      {
        name: "Depth",
        ...a
      },
      (e2) => {
        e2.schema.push({
          value: e2.mapping,
          label: "mapping",
          options: ["vector", "world", "camera"]
        });
        const t = v2.getMapping(e2.uuid, e2.mapping);
        e2.fragmentShader = e2.fragmentShader.replace("lamina_mapping_template", t);
      }
    ), this.mapping = "vector";
  }
  static getMapping(a, e2) {
    switch (e2) {
      default:
      case "vector":
        return `length(v_${a}_worldPosition - u_${a}_origin)`;
      case "world":
        return `length(v_${a}_position - vec3(0.))`;
      case "camera":
        return `length(v_${a}_worldPosition - cameraPosition)`;
    }
  }
};
v.u_near = 2, v.u_far = 10, v.u_origin = new Vector3(0, 0, 0), v.u_colorA = "white", v.u_colorB = "black", v.u_alpha = 1, v.vertexShader = `
  varying vec3 v_worldPosition;
  varying vec3 v_position;

  void main() {
    v_worldPosition = (vec4(position, 1.0) * modelMatrix).xyz;
    v_position = position;
  }
  `, v.fragmentShader = `   
    uniform float u_alpha;
    uniform float u_near;
    uniform float u_far;
    uniform float u_isVector;
    uniform vec3 u_origin;
    uniform vec3 u_colorA;
    uniform vec3 u_colorB;

    varying vec3 v_worldPosition;
    varying vec3 v_position;

    void main() {
      float f_dist = lamina_mapping_template;
      float f_depth = (f_dist - u_near) / (u_far - u_near);
			vec3 f_depthColor =  mix(u_colorB, u_colorA, 1.0 - clamp(f_depth, 0., 1.));
  
  
      return vec4(f_depthColor, u_alpha);
    }
  `;
var $ = v;
var u = class u2 extends x2 {
  constructor(a) {
    super(
      u2,
      {
        name: "Displace",
        ...a
      },
      (e2) => {
        e2.schema.push({
          value: e2.type,
          label: "type",
          options: Object.values(R)
        }), e2.schema.push({
          value: e2.mapping,
          label: "mapping",
          options: Object.values(k2)
        });
        const t = u2.getNoiseFunction(e2.type), n = u2.getMapping(e2.mapping);
        e2.vertexVariables = e2.vertexVariables.replace("lamina_mapping_template", n), e2.vertexVariables = e2.vertexVariables.replace("lamina_noise_template", t);
      }
    ), this.type = "perlin", this.mapping = "local";
  }
  static getNoiseFunction(a) {
    switch (a) {
      default:
      case "perlin":
        return "lamina_noise_perlin";
      case "simplex":
        return "lamina_noise_simplex";
      case "cell":
        return "lamina_noise_worley";
      case "white":
        return "lamina_noise_white";
      case "curl":
        return "lamina_noise_swirl";
    }
  }
  static getMapping(a) {
    switch (a) {
      default:
      case "local":
        return "p";
      case "world":
        return "(modelMatrix * vec4(p,1.0)).xyz";
      case "uv":
        return "vec3(uv, 0.)";
    }
  }
};
u.u_strength = 1, u.u_scale = 1, u.u_offset = new Vector3(0, 0, 0), u.vertexShader = `
       
      uniform float u_strength;
      uniform float u_scale;
      uniform vec3 u_offset;

      vec3 displace(vec3 p) {
				vec3 f_position = lamina_mapping_template;
        float f_n = lamina_noise_template((f_position + u_offset) * u_scale) * u_strength;
        vec3 f_newPosition = p + (f_n * normal);

				return f_newPosition;
      }

      
			vec3 orthogonal(vec3 v) {
  		  return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)
  		  : vec3(0.0, -v.z, v.y));
  		}
  		vec3 recalcNormals(vec3 newPos) {
  		  float offset = 0.001;
  		  vec3 tangent = orthogonal(normal);
  		  vec3 bitangent = normalize(cross(normal, tangent));
  		  vec3 neighbour1 = position + tangent * offset;
  		  vec3 neighbour2 = position + bitangent * offset;
  		  vec3 displacedNeighbour1 = displace(neighbour1);
  		  vec3 displacedNeighbour2 = displace(neighbour2);
  		  vec3 displacedTangent = displacedNeighbour1 - newPos;
  		  vec3 displacedBitangent = displacedNeighbour2 - newPos;
  		  return normalize(cross(displacedTangent, displacedBitangent));
  		}
  
  
      void main() {
       
				vec3 f_newPosition = displace(position);
        lamina_finalNormal = recalcNormals(f_newPosition);

        return f_newPosition;
      }
    `;
var j2 = u;
var _ = class _2 extends x2 {
  constructor(a) {
    super(_2, {
      name: "Fresnel",
      ...a
    });
  }
};
_.u_color = "white", _.u_alpha = 1, _.u_bias = 0, _.u_intensity = 1, _.u_power = 2, _.u_factor = 1, _.vertexShader = `
    varying vec3 v_worldPosition;
    varying vec3 v_worldNormal;

    void main() {
        v_worldPosition = vec3(-viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2]);
        v_worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );
        
    }
  `, _.fragmentShader = `   
    uniform vec3 u_color;
    uniform float u_alpha;
    uniform float u_bias;
    uniform float u_intensity;
    uniform float u_power;
    uniform float u_factor;

    varying vec3 v_worldPosition;
    varying vec3 v_worldNormal;

    void main() {
        float f_a = (u_factor  + dot(v_worldPosition, v_worldNormal));
        float f_fresnel = u_bias + u_intensity * pow(abs(f_a), u_power);

        f_fresnel = clamp(f_fresnel, 0.0, 1.0);
        return vec4(f_fresnel * u_color, u_alpha);
    }
  `;
var M = _;
var d = class d2 extends x2 {
  constructor(a) {
    super(
      d2,
      {
        name: "Gradient",
        ...a
      },
      (e2) => {
        e2.schema.push({
          value: e2.axes,
          label: "axes",
          options: ["x", "y", "z"]
        }), e2.schema.push({
          value: e2.mapping,
          label: "mapping",
          options: Object.values(k2)
        });
        const t = d2.getMapping(e2.mapping);
        e2.vertexShader = e2.vertexShader.replace("lamina_mapping_template", t || "local"), e2.fragmentShader = e2.fragmentShader.replace("axes_template", e2.axes || "x");
      }
    ), this.axes = "x", this.mapping = "local";
  }
  static getMapping(a) {
    switch (a) {
      default:
      case "local":
        return "position";
      case "world":
        return "(modelMatrix * vec4(position,1.0)).xyz";
      case "uv":
        return "vec3(uv, 0.)";
    }
  }
};
d.u_colorA = "white", d.u_colorB = "black", d.u_alpha = 1, d.u_start = 1, d.u_end = -1, d.u_contrast = 1, d.vertexShader = `
		varying vec3 v_position;

		vod main() {
      v_position = lamina_mapping_template;
		}
  `, d.fragmentShader = `   
    uniform vec3 u_colorA;
    uniform vec3 u_colorB;
    uniform vec3 u_axis;
    uniform float u_alpha;
    uniform float u_start;
    uniform float u_end;
    uniform float u_contrast;

		varying vec3 v_position;

    void main() {

      float f_step = smoothstep(u_start, u_end, v_position.axes_template * u_contrast);
      vec3 f_color = mix(u_colorA, u_colorB, f_step);

      return vec4(f_color, u_alpha);
    }
  `;
var F2 = d;
var p = class p2 extends x2 {
  constructor(a) {
    super(p2, {
      name: "Matcap",
      ...a
    });
  }
};
p.u_alpha = 1, p.u_map = void 0, p.vertexShader = `
    varying vec3 v_position;
    varying vec3 v_normal;
    
    void main() {
      v_position = normalize( vec3( modelViewMatrix * vec4( position, 1.0 ) ) );
      v_normal = normalize( normalMatrix * normal );
    }
    `, p.fragmentShader = ` 
		uniform sampler2D u_map;  
		uniform float u_alpha;  
		varying vec3 v_position;
		varying vec3 v_normal;

		
    void main() {
			vec3 f_r = reflect( v_position, v_normal );
			float f_m = 2. * sqrt( pow( f_r.x, 2. ) + pow( f_r.y, 2. ) + pow( f_r.z + 1., 2. ) );
			vec2 f_vN = f_r.xy / f_m + .5;

			vec3 f_base = texture2D(u_map, f_vN).rgb;

      return vec4(f_base, u_alpha);
    }
  `;
var C = p;
var s = class s2 extends x2 {
  constructor(a) {
    super(
      s2,
      {
        name: "noise",
        ...a
      },
      (e2) => {
        e2.schema.push({
          value: e2.type,
          label: "type",
          options: Object.values(R)
        }), e2.schema.push({
          value: e2.mapping,
          label: "mapping",
          options: Object.values(k2)
        });
        const t = s2.getNoiseFunction(e2.type), n = s2.getMapping(e2.mapping);
        e2.vertexShader = e2.vertexShader.replace("lamina_mapping_template", n), e2.fragmentShader = e2.fragmentShader.replace("lamina_noise_template", t);
      }
    ), this.type = "perlin", this.mapping = "local";
  }
  static getNoiseFunction(a) {
    switch (a) {
      default:
      case "perlin":
        return "lamina_noise_perlin";
      case "simplex":
        return "lamina_noise_simplex";
      case "cell":
        return "lamina_noise_worley";
      case "white":
        return "lamina_noise_white";
      case "curl":
        return "lamina_noise_swirl";
    }
  }
  static getMapping(a) {
    switch (a) {
      default:
      case "local":
        return "position";
      case "world":
        return "(modelMatrix * vec4(position,1.0)).xyz";
      case "uv":
        return "vec3(uv, 0.)";
    }
  }
};
s.u_colorA = "#666666", s.u_colorB = "#666666", s.u_colorC = "#FFFFFF", s.u_colorD = "#FFFFFF", s.u_alpha = 1, s.u_scale = 1, s.u_offset = new Vector3(0, 0, 0), s.vertexShader = `
    varying vec3 v_position;

    void main() {
        v_position = lamina_mapping_template;
    }
  `, s.fragmentShader = `   
    uniform vec3 u_colorA;
    uniform vec3 u_colorB;
    uniform vec3 u_colorC;
    uniform vec3 u_colorD;
    uniform vec3 u_offset;

    uniform float u_alpha;
    uniform float u_scale;

    varying vec3 v_position;


    void main() {
        float f_n = lamina_noise_template((v_position + u_offset) * u_scale);

        float f_step1 = 0.;
        float f_step2 = 0.2;
        float f_step3 = 0.6;
        float f_step4 = 1.;

        vec3 f_color = mix(u_colorA, u_colorB, smoothstep(f_step1, f_step2, f_n));
        f_color = mix(f_color, u_colorC, smoothstep(f_step2, f_step3, f_n));
        f_color = mix(f_color, u_colorD, smoothstep(f_step3, f_step4, f_n));

        return vec4(f_color, u_alpha);
    }
  `;
var O2 = s;
var h = class h2 extends x2 {
  constructor(a) {
    super(h2, {
      name: "Normal",
      ...a
    });
  }
};
h.u_alpha = 1, h.u_direction = new Vector3(1, 1, 1), h.vertexShader = `   
  varying vec3 v_normals; 

  void main() {
    v_normals = normal;
  }
`, h.fragmentShader = `   
  	uniform float u_alpha;
  	uniform vec3 u_color;
  	uniform vec3 u_direction;

		varying vec3 v_normals;

    void main() {
			vec3 f_normalColor = vec3(1.);
      f_normalColor.x = v_normals.x * u_direction.x;
      f_normalColor.y = v_normals.y * u_direction.y;
      f_normalColor.z = v_normals.z * u_direction.z;

      return vec4(f_normalColor, u_alpha);
    }
  `;
var B = h;
var g = class g2 extends x2 {
  constructor(a) {
    super(g2, {
      name: "Texture",
      ...a
    });
  }
};
g.u_alpha = 1, g.u_map = void 0, g.vertexShader = `
    varying vec2 v_uv;
    
    void main() {
        v_uv = uv;
    }
    `, g.fragmentShader = ` 
		uniform sampler2D u_map;  
		uniform float u_alpha;  
		varying vec2 v_uv;

    void main() {
			vec4 f_color = texture2D(u_map, v_uv);
      return vec4(f_color.rgb, f_color.a * u_alpha);
    }
  `;
var N = g;
var ie = (
  /* glsl */
  `
vec4 lamina_blend_add(const in vec4 x, const in vec4 y, const in float opacity) {

	return vec4(min(x.xyz + y.xyz, 1.0) * opacity + x.xyz * (1.0 - opacity), x.a);

}
vec3 lamina_blend_alpha(const in vec3 x, const in vec3 y, const in float opacity) {

	return y * opacity + x * (1.0 - opacity);

}

vec4 lamina_blend_alpha(const in vec4 x, const in vec4 y, const in float opacity) {

	float a = min(y.a, opacity);

	return vec4(lamina_blend_alpha(x.rgb, y.rgb, a), x.a);

}
vec4 lamina_blend_average(const in vec4 x, const in vec4 y, const in float opacity) {

	return vec4((x.xyz + y.xyz) * 0.5 * opacity + x.xyz * (1.0 - opacity), x.a);

}
float lamina_blend_color_burn(const in float x, const in float y) {

	return (y == 0.0) ? y : max(1.0 - (1.0 - x) / y, 0.0);

}

vec4 lamina_blend_color_burn(const in vec4 x, const in vec4 y, const in float opacity) {

	vec4 z = vec4(
		lamina_blend_color_burn(x.r, y.r),
		lamina_blend_color_burn(x.g, y.g),
		lamina_blend_color_burn(x.b, y.b),
		lamina_blend_color_burn(x.a, y.a)
	);

	return vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);

}
float lamina_blend_color_dodge(const in float x, const in float y) {

	return (y == 1.0) ? y : min(x / (1.0 - y), 1.0);

}

vec4 lamina_blend_color_dodge(const in vec4 x, const in vec4 y, const in float opacity) {

	vec4 z = vec4(
		lamina_blend_color_dodge(x.r, y.r),
		lamina_blend_color_dodge(x.g, y.g),
		lamina_blend_color_dodge(x.b, y.b),
		lamina_blend_color_dodge(x.a, y.a)
	);

	return vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);

}
vec4 lamina_blend_darken(const in vec4 x, const in vec4 y, const in float opacity) {

	return vec4(min(x.xyz, y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);

}
vec4 lamina_blend_difference(const in vec4 x, const in vec4 y, const in float opacity) {

	return vec4(abs(x.xyz - y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);

}
float lamina_blend_divide(const in float x, const in float y) {

	return (y > 0.0) ? min(x / y, 1.0) : 1.0;

}

vec4 lamina_blend_divide(const in vec4 x, const in vec4 y, const in float opacity) {

	vec4 z = vec4(
		lamina_blend_divide(x.r, y.r),
		lamina_blend_divide(x.g, y.g),
		lamina_blend_divide(x.b, y.b),
		lamina_blend_divide(x.a, y.a)
	);

	return vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);

}
vec4 lamina_blend_exclusion(const in vec4 x, const in vec4 y, const in float opacity) {

	return vec4((x.xyz + y.xyz - 2.0 * x.xyz * y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);

}
vec4 lamina_blend_lighten(const in vec4 x, const in vec4 y, const in float opacity) {

	return vec4(max(x.xyz, y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);

}
vec4 lamina_blend_multiply(const in vec4 x, const in vec4 y, const in float opacity) {

	return vec4( x.xyz * y.xyz * opacity + x.xyz * (1.0 - opacity), x.a);

}
vec4 lamina_blend_negation(const in vec4 x, const in vec4 y, const in float opacity) {

	return vec4((1.0 - abs(1.0 - x.xyz - y.xyz)) * opacity + x.xyz * (1.0 - opacity), x.a);

}
vec4 lamina_blend_normal(const in vec4 x, const in vec4 y, const in float opacity) {

	return vec4(y.xyz * opacity + x.xyz * (1.0 - opacity), x.a);

}
float lamina_blend_overlay(const in float x, const in float y) {

	return (x < 0.5) ? (2.0 * x * y) : (1.0 - 2.0 * (1.0 - x) * (1.0 - y));

}

vec4 lamina_blend_overlay(const in vec4 x, const in vec4 y, const in float opacity) {

	vec4 z = vec4(
		lamina_blend_overlay(x.r, y.r),
		lamina_blend_overlay(x.g, y.g),
		lamina_blend_overlay(x.b, y.b),
		lamina_blend_overlay(x.a, y.a)
	);

	return vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);

}
float lamina_blend_reflect(const in float x, const in float y) {

	return (y == 1.0) ? y : min(x * x / (1.0 - y), 1.0);

}

vec4 lamina_blend_reflect(const in vec4 x, const in vec4 y, const in float opacity) {

	vec4 z = vec4(
		lamina_blend_reflect(x.r, y.r),
		lamina_blend_reflect(x.g, y.g),
		lamina_blend_reflect(x.b, y.b),
		lamina_blend_reflect(x.a, y.a)
	);

	return vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);

}
vec4 lamina_blend_screen(const in vec4 x, const in vec4 y, const in float opacity) {

	return vec4((1.0 - (1.0 - x.xyz) * (1.0 - y.xyz)) * opacity + x.xyz * (1.0 - opacity), x.a);

}
float lamina_blend_softlight(const in float x, const in float y) {

	return (y < 0.5) ?
		(2.0 * x * y + x * x * (1.0 - 2.0 * y)) :
		(sqrt(x) * (2.0 * y - 1.0) + 2.0 * x * (1.0 - y));

}

vec4 lamina_blend_softlight(const in vec4 x, const in vec4 y, const in float opacity) {

	vec4 z = vec4(
		lamina_blend_softlight(x.r, y.r),
		lamina_blend_softlight(x.g, y.g),
		lamina_blend_softlight(x.b, y.b),
		lamina_blend_softlight(x.a, y.a)
	);

	return vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);

}
vec4 lamina_blend_subtract(const in vec4 x, const in vec4 y, const in float opacity) {

	return vec4(max(x.xyz + y.xyz - 1.0, 0.0) * opacity + x.xyz * (1.0 - opacity), x.a);

}

`
);
var L = (
  /* glsl */
  `

float lamina_map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

float lamina_normalize(float v) { return lamina_map(v, -1.0, 1.0, 0.0, 1.0); }
`
);
var W = (
  /* glsl */
  `

// From: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83
// Huge thanks to the creators of these algorithms

float lamina_noise_mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
vec4 lamina_noise_mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
vec4 lamina_noise_perm(vec4 x){return lamina_noise_mod289(((x * 34.0) + 1.0) * x);}
vec4 lamina_noise_permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }
vec4 lamina_noise_taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }


float lamina_noise_white(vec2 p) {
  return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) *
               (0.1 + abs(sin(p.y * 13.0 + p.x))));
}

float lamina_noise_white(vec3 p) {
  return lamina_noise_white(p.xy);
}


vec3 lamina_noise_fade(vec3 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }

float lamina_noise_perlin(vec3 P) {
  vec3 Pi0 = floor(P);        // Integer part for indexing
  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
  Pi0 = mod(Pi0, 289.0);
  Pi1 = mod(Pi1, 289.0);
  vec3 Pf0 = fract(P);        // Fractional part for interpolation
  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = Pi0.zzzz;
  vec4 iz1 = Pi1.zzzz;

  vec4 ixy = lamina_noise_permute(lamina_noise_permute(ix) + iy);
  vec4 ixy0 = lamina_noise_permute(ixy + iz0);
  vec4 ixy1 = lamina_noise_permute(ixy + iz1);

  vec4 gx0 = ixy0 / 7.0;
  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
  gx0 = fract(gx0);
  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
  vec4 sz0 = step(gz0, vec4(0.0));
  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

  vec4 gx1 = ixy1 / 7.0;
  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
  gx1 = fract(gx1);
  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
  vec4 sz1 = step(gz1, vec4(0.0));
  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

  vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);
  vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);
  vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);
  vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);
  vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);
  vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);
  vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);
  vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);

  vec4 norm0 = lamina_noise_taylorInvSqrt(
      vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  vec4 norm1 = lamina_noise_taylorInvSqrt(
      vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  float n000 = dot(g000, Pf0);
  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
  float n111 = dot(g111, Pf1);

  vec3 fade_xyz = lamina_noise_fade(Pf0);
  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111),
                 fade_xyz.z);
  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
  return lamina_normalize(2.2 * n_xyz);
}

float lamina_noise_simplex(vec3 v) {
  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);
  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

  // First corner
  vec3 i = floor(v + dot(v, C.yyy));
  vec3 x0 = v - i + dot(i, C.xxx);

  // Other corners
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min(g.xyz, l.zxy);
  vec3 i2 = max(g.xyz, l.zxy);

  //  x0 = x0 - 0. + 0.0 * C
  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
  vec3 x3 = x0 - 1. + 3.0 * C.xxx;

  // Permutations
  i = mod(i, 289.0);
  vec4 p = lamina_noise_permute(lamina_noise_permute(lamina_noise_permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y +
                             vec4(0.0, i1.y, i2.y, 1.0)) +
                    i.x + vec4(0.0, i1.x, i2.x, 1.0));

  // Gradients
  // ( N*N points uniformly over a square, mapped onto an octahedron.)
  float n_ = 1.0 / 7.0; // N=7
  vec3 ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); //  mod(p,N*N)

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_); // mod(j,N)

  vec4 x = x_ * ns.x + ns.yyyy;
  vec4 y = y_ * ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);

  vec4 b0 = vec4(x.xy, y.xy);
  vec4 b1 = vec4(x.zw, y.zw);

  vec4 s0 = floor(b0) * 2.0 + 1.0;
  vec4 s1 = floor(b1) * 2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));

  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

  vec3 p0 = vec3(a0.xy, h.x);
  vec3 p1 = vec3(a0.zw, h.y);
  vec3 p2 = vec3(a1.xy, h.z);
  vec3 p3 = vec3(a1.zw, h.w);

  // Normalise gradients
  vec4 norm =
      lamina_noise_taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

  // Mix final noise value
  vec4 m =
      max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
  m = m * m;
  return lamina_normalize(42.0 *
         dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3))));
}

vec3 lamina_noise_simplex3(vec3 x) {
  float s = lamina_noise_simplex(vec3(x));
  float s1 = lamina_noise_simplex(vec3(x.y - 19.1, x.z + 33.4, x.x + 47.2));
  float s2 = lamina_noise_simplex(vec3(x.z + 74.2, x.x - 124.5, x.y + 99.4));
  vec3 c = vec3(s, s1, s2);
  return c;
}

vec3 lamina_noise_curl(vec3 p) {
  const float e = .1;
  vec3 dx = vec3(e, 0.0, 0.0);
  vec3 dy = vec3(0.0, e, 0.0);
  vec3 dz = vec3(0.0, 0.0, e);

  vec3 p_x0 = lamina_noise_simplex3(p - dx);
  vec3 p_x1 = lamina_noise_simplex3(p + dx);
  vec3 p_y0 = lamina_noise_simplex3(p - dy);
  vec3 p_y1 = lamina_noise_simplex3(p + dy);
  vec3 p_z0 = lamina_noise_simplex3(p - dz);
  vec3 p_z1 = lamina_noise_simplex3(p + dz);

  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;
  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;
  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;

  const float divisor = 1.0 / (2.0 * e);
  return normalize(vec3(x, y, z) * divisor);
}

vec3 lamina_permute(vec3 x) {
  return mod((34.0 * x + 1.0) * x, 289.0);
}

vec3 lamina_dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance) {
  return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);
}

// From: https://github.com/Erkaman/glsl-worley
float lamina_noise_worley(vec3 P) {
  float jitter = 1.;
  bool manhattanDistance = false; 

  float K = 0.142857142857; // 1/7
  float Ko = 0.428571428571; // 1/2-K/2
  float  K2 = 0.020408163265306; // 1/(7*7)
  float Kz = 0.166666666667; // 1/6
  float Kzo = 0.416666666667; // 1/2-1/6*2

	vec3 Pi = mod(floor(P), 289.0);
 	vec3 Pf = fract(P) - 0.5;

	vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);
	vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);
	vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);

	vec3 p = lamina_permute(Pi.x + vec3(-1.0, 0.0, 1.0));
	vec3 p1 = lamina_permute(p + Pi.y - 1.0);
	vec3 p2 = lamina_permute(p + Pi.y);
	vec3 p3 = lamina_permute(p + Pi.y + 1.0);

	vec3 p11 = lamina_permute(p1 + Pi.z - 1.0);
	vec3 p12 = lamina_permute(p1 + Pi.z);
	vec3 p13 = lamina_permute(p1 + Pi.z + 1.0);

	vec3 p21 = lamina_permute(p2 + Pi.z - 1.0);
	vec3 p22 = lamina_permute(p2 + Pi.z);
	vec3 p23 = lamina_permute(p2 + Pi.z + 1.0);

	vec3 p31 = lamina_permute(p3 + Pi.z - 1.0);
	vec3 p32 = lamina_permute(p3 + Pi.z);
	vec3 p33 = lamina_permute(p3 + Pi.z + 1.0);

	vec3 ox11 = fract(p11*K) - Ko;
	vec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;
	vec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed

	vec3 ox12 = fract(p12*K) - Ko;
	vec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;
	vec3 oz12 = floor(p12*K2)*Kz - Kzo;

	vec3 ox13 = fract(p13*K) - Ko;
	vec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;
	vec3 oz13 = floor(p13*K2)*Kz - Kzo;

	vec3 ox21 = fract(p21*K) - Ko;
	vec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;
	vec3 oz21 = floor(p21*K2)*Kz - Kzo;

	vec3 ox22 = fract(p22*K) - Ko;
	vec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;
	vec3 oz22 = floor(p22*K2)*Kz - Kzo;

	vec3 ox23 = fract(p23*K) - Ko;
	vec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;
	vec3 oz23 = floor(p23*K2)*Kz - Kzo;

	vec3 ox31 = fract(p31*K) - Ko;
	vec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;
	vec3 oz31 = floor(p31*K2)*Kz - Kzo;

	vec3 ox32 = fract(p32*K) - Ko;
	vec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;
	vec3 oz32 = floor(p32*K2)*Kz - Kzo;

	vec3 ox33 = fract(p33*K) - Ko;
	vec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;
	vec3 oz33 = floor(p33*K2)*Kz - Kzo;

	vec3 dx11 = Pfx + jitter*ox11;
	vec3 dy11 = Pfy.x + jitter*oy11;
	vec3 dz11 = Pfz.x + jitter*oz11;

	vec3 dx12 = Pfx + jitter*ox12;
	vec3 dy12 = Pfy.x + jitter*oy12;
	vec3 dz12 = Pfz.y + jitter*oz12;

	vec3 dx13 = Pfx + jitter*ox13;
	vec3 dy13 = Pfy.x + jitter*oy13;
	vec3 dz13 = Pfz.z + jitter*oz13;

	vec3 dx21 = Pfx + jitter*ox21;
	vec3 dy21 = Pfy.y + jitter*oy21;
	vec3 dz21 = Pfz.x + jitter*oz21;

	vec3 dx22 = Pfx + jitter*ox22;
	vec3 dy22 = Pfy.y + jitter*oy22;
	vec3 dz22 = Pfz.y + jitter*oz22;

	vec3 dx23 = Pfx + jitter*ox23;
	vec3 dy23 = Pfy.y + jitter*oy23;
	vec3 dz23 = Pfz.z + jitter*oz23;

	vec3 dx31 = Pfx + jitter*ox31;
	vec3 dy31 = Pfy.z + jitter*oy31;
	vec3 dz31 = Pfz.x + jitter*oz31;

	vec3 dx32 = Pfx + jitter*ox32;
	vec3 dy32 = Pfy.z + jitter*oy32;
	vec3 dz32 = Pfz.y + jitter*oz32;

	vec3 dx33 = Pfx + jitter*ox33;
	vec3 dy33 = Pfy.z + jitter*oy33;
	vec3 dz33 = Pfz.z + jitter*oz33;

	vec3 d11 = lamina_dist(dx11, dy11, dz11, manhattanDistance);
	vec3 d12 = lamina_dist(dx12, dy12, dz12, manhattanDistance);
	vec3 d13 = lamina_dist(dx13, dy13, dz13, manhattanDistance);
	vec3 d21 = lamina_dist(dx21, dy21, dz21, manhattanDistance);
	vec3 d22 = lamina_dist(dx22, dy22, dz22, manhattanDistance);
	vec3 d23 = lamina_dist(dx23, dy23, dz23, manhattanDistance);
	vec3 d31 = lamina_dist(dx31, dy31, dz31, manhattanDistance);
	vec3 d32 = lamina_dist(dx32, dy32, dz32, manhattanDistance);
	vec3 d33 = lamina_dist(dx33, dy33, dz33, manhattanDistance);

	vec3 d1a = min(d11, d12);
	d12 = max(d11, d12);
	d11 = min(d1a, d13); // Smallest now not in d12 or d13
	d13 = max(d1a, d13);
	d12 = min(d12, d13); // 2nd smallest now not in d13
	vec3 d2a = min(d21, d22);
	d22 = max(d21, d22);
	d21 = min(d2a, d23); // Smallest now not in d22 or d23
	d23 = max(d2a, d23);
	d22 = min(d22, d23); // 2nd smallest now not in d23
	vec3 d3a = min(d31, d32);
	d32 = max(d31, d32);
	d31 = min(d3a, d33); // Smallest now not in d32 or d33
	d33 = max(d3a, d33);
	d32 = min(d32, d33); // 2nd smallest now not in d33
	vec3 da = min(d11, d21);
	d21 = max(d11, d21);
	d11 = min(da, d31); // Smallest now in d11
	d31 = max(da, d31); // 2nd smallest now not in d31
	d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;
	d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest
	d12 = min(d12, d21); // 2nd smallest now not in d21
	d12 = min(d12, d22); // nor in d22
	d12 = min(d12, d31); // nor in d31
	d12 = min(d12, d32); // nor in d32
	d11.yz = min(d11.yz,d12.xy); // nor in d12.yz
	d11.y = min(d11.y,d12.z); // Only two more to go
	d11.y = min(d11.y,d11.z); // Done! (Phew!)

  vec2 F = sqrt(d11.xy);
	return F.x; // F1, F2

}

float lamina_noise_swirl(vec3 position) {
    float scale = 0.1;
    float freq = 4. * scale;
    float t = 1.;

    vec3 pos = (position * scale) + lamina_noise_curl(position * 7. * scale);

    float worley1 = 1. - lamina_noise_worley((pos * (freq * 2.)) +  (t * 2.));
    float worley2 = 1. - lamina_noise_worley((pos * (freq * 4.)) +  (t * 4.));
    float worley3 = 1. - lamina_noise_worley((pos * (freq * 8.)) +  (t * 8.));
    float worley4 = 1. - lamina_noise_worley((pos * (freq * 16.)) +  (t * 16.));
    
    float fbm1 = worley1 * .625 + worley2 * .25 + worley3 * .125;
    float fbm2 = worley2 * .625 + worley3 * .25 + worley4 * .125;
    float fbm3 = worley3 * .75 + worley4 * .25;

    vec3 curlWorleyFbm = vec3(fbm1, fbm2, fbm3);
    float curlWorley = curlWorleyFbm.r * .625 + curlWorleyFbm.g * .25 + 
        curlWorleyFbm.b * .125;

    return curlWorley;
}
  
  
`
);
var ne = class extends j {
  constructor({ color: a, alpha: e2, lighting: t, layers: n, name: i, ...o } = {}) {
    super({
      baseMaterial: ae[t || "basic"],
      ...o
    }), this.name = "LayerMaterial", this.layers = [], this.lighting = "basic";
    const c = a || "white", l = e2 ?? 1;
    this.uniforms = {
      u_lamina_color: {
        value: typeof c == "string" ? new Color(c).convertSRGBToLinear() : c
      },
      u_lamina_alpha: {
        value: l
      }
    }, this.layers = n || this.layers, this.lighting = t || this.lighting, this.name = i || this.name, this.refresh();
  }
  genShaders() {
    let a = "", e2 = "", t = "", n = "", i = {};
    return this.layers.filter((o) => o.visible).forEach((o) => {
      a += o.vertexVariables + `
`, e2 += o.fragmentVariables + `
`, t += o.vertexShader + `
`, n += o.fragmentShader + `
`, i = {
        ...i,
        ...o.uniforms
      };
    }), i = {
      ...i,
      ...this.uniforms
    }, {
      uniforms: i,
      vertexShader: `
        ${L}
        ${W}
        ${a}

        void main() {
          vec3 lamina_finalPosition = position;
          vec3 lamina_finalNormal = normal;

          ${t}

          csm_Position = lamina_finalPosition;
          csm_Normal = lamina_finalNormal;
        }
        `,
      fragmentShader: `
        ${L}
        ${W}
        ${ie}
        ${e2}

        uniform vec3 u_lamina_color;
        uniform float u_lamina_alpha;

        void main() {
          vec4 lamina_finalColor = vec4(u_lamina_color, u_lamina_alpha);

          ${n}

          csm_DiffuseColor = lamina_finalColor;
         
        }
        `
    };
  }
  refresh() {
    const { uniforms: a, fragmentShader: e2, vertexShader: t } = this.genShaders();
    super.update({ fragmentShader: e2, vertexShader: t, uniforms: a });
  }
  serialize() {
    return {
      constructor: "LayerMaterial",
      properties: {
        color: this.color,
        alpha: this.alpha,
        name: this.name,
        lighting: this.lighting
      }
    };
  }
  set color(a) {
    var e2, t;
    (t = (e2 = this.uniforms) == null ? void 0 : e2.u_lamina_color) != null && t.value && (this.uniforms.u_lamina_color.value = typeof a == "string" ? new Color(a).convertSRGBToLinear() : a);
  }
  get color() {
    var a, e2;
    return (e2 = (a = this.uniforms) == null ? void 0 : a.u_lamina_color) == null ? void 0 : e2.value;
  }
  set alpha(a) {
    this.uniforms.u_lamina_alpha.value = a;
  }
  get alpha() {
    return this.uniforms.u_lamina_alpha.value;
  }
};
var de = Object.freeze(Object.defineProperty({
  __proto__: null,
  Abstract: x2,
  Color: S,
  Depth: $,
  Displace: j2,
  Fresnel: M,
  Gradient: F2,
  LayerMaterial: ne,
  Matcap: C,
  Noise: O2,
  Normal: B,
  Texture: N
}, Symbol.toStringTag, { value: "Module" }));

export {
  ae,
  q,
  ve,
  x2 as x,
  S,
  $,
  j2 as j,
  M,
  F2 as F,
  C,
  O2 as O,
  B,
  N,
  ne,
  de
};
//# sourceMappingURL=chunk-V2AHPT5P.js.map
