{
  "version": 3,
  "sources": ["../../glsl-tokenizer/lib/literals.js", "../../glsl-tokenizer/lib/operators.js", "../../glsl-tokenizer/lib/builtins.js", "../../glsl-tokenizer/lib/literals-300es.js", "../../glsl-tokenizer/lib/builtins-300es.js", "../../glsl-tokenizer/index.js", "../../glsl-tokenizer/string.js", "../../glsl-token-depth/index.js", "../../glsl-token-scope/index.js", "../../glsl-token-properties/index.js", "../../glsl-token-assignments/assignments.js", "../../glsl-token-assignments/ignored.js", "../../glsl-token-assignments/index.js", "../../glsl-token-descope/index.js", "../../glsl-token-string/index.js", "../../glsl-token-functions/index.js", "../../src/types.ts", "../../src/utils/Functions.ts", "../../src/core/Abstract.ts", "../../src/core/Color.ts", "../../src/core/Depth.ts", "../../src/core/Displace.ts", "../../src/core/Fresnel.ts", "../../src/core/Gradient.ts", "../../src/core/Matcap.ts", "../../src/core/Noise.ts", "../../src/core/Normal.ts", "../../src/core/Texture.ts", "../../src/chunks/BlendModes.ts", "../../src/chunks/Helpers.ts", "../../src/chunks/Noise.ts", "../../src/vanilla.ts"],
  "sourcesContent": ["module.exports = [\r\n  // current\r\n    'precision'\r\n  , 'highp'\r\n  , 'mediump'\r\n  , 'lowp'\r\n  , 'attribute'\r\n  , 'const'\r\n  , 'uniform'\r\n  , 'varying'\r\n  , 'break'\r\n  , 'continue'\r\n  , 'do'\r\n  , 'for'\r\n  , 'while'\r\n  , 'if'\r\n  , 'else'\r\n  , 'in'\r\n  , 'out'\r\n  , 'inout'\r\n  , 'float'\r\n  , 'int'\r\n  , 'uint'\r\n  , 'void'\r\n  , 'bool'\r\n  , 'true'\r\n  , 'false'\r\n  , 'discard'\r\n  , 'return'\r\n  , 'mat2'\r\n  , 'mat3'\r\n  , 'mat4'\r\n  , 'vec2'\r\n  , 'vec3'\r\n  , 'vec4'\r\n  , 'ivec2'\r\n  , 'ivec3'\r\n  , 'ivec4'\r\n  , 'bvec2'\r\n  , 'bvec3'\r\n  , 'bvec4'\r\n  , 'sampler1D'\r\n  , 'sampler2D'\r\n  , 'sampler3D'\r\n  , 'samplerCube'\r\n  , 'sampler1DShadow'\r\n  , 'sampler2DShadow'\r\n  , 'struct'\r\n\r\n  // future\r\n  , 'asm'\r\n  , 'class'\r\n  , 'union'\r\n  , 'enum'\r\n  , 'typedef'\r\n  , 'template'\r\n  , 'this'\r\n  , 'packed'\r\n  , 'goto'\r\n  , 'switch'\r\n  , 'default'\r\n  , 'inline'\r\n  , 'noinline'\r\n  , 'volatile'\r\n  , 'public'\r\n  , 'static'\r\n  , 'extern'\r\n  , 'external'\r\n  , 'interface'\r\n  , 'long'\r\n  , 'short'\r\n  , 'double'\r\n  , 'half'\r\n  , 'fixed'\r\n  , 'unsigned'\r\n  , 'input'\r\n  , 'output'\r\n  , 'hvec2'\r\n  , 'hvec3'\r\n  , 'hvec4'\r\n  , 'dvec2'\r\n  , 'dvec3'\r\n  , 'dvec4'\r\n  , 'fvec2'\r\n  , 'fvec3'\r\n  , 'fvec4'\r\n  , 'sampler2DRect'\r\n  , 'sampler3DRect'\r\n  , 'sampler2DRectShadow'\r\n  , 'sizeof'\r\n  , 'cast'\r\n  , 'namespace'\r\n  , 'using'\r\n]\r\n", "module.exports = [\r\n    '<<='\r\n  , '>>='\r\n  , '++'\r\n  , '--'\r\n  , '<<'\r\n  , '>>'\r\n  , '<='\r\n  , '>='\r\n  , '=='\r\n  , '!='\r\n  , '&&'\r\n  , '||'\r\n  , '+='\r\n  , '-='\r\n  , '*='\r\n  , '/='\r\n  , '%='\r\n  , '&='\r\n  , '^^'\r\n  , '^='\r\n  , '|='\r\n  , '('\r\n  , ')'\r\n  , '['\r\n  , ']'\r\n  , '.'\r\n  , '!'\r\n  , '~'\r\n  , '*'\r\n  , '/'\r\n  , '%'\r\n  , '+'\r\n  , '-'\r\n  , '<'\r\n  , '>'\r\n  , '&'\r\n  , '^'\r\n  , '|'\r\n  , '?'\r\n  , ':'\r\n  , '='\r\n  , ','\r\n  , ';'\r\n  , '{'\r\n  , '}'\r\n]\r\n", "module.exports = [\r\n  // Keep this list sorted\r\n  'abs'\r\n  , 'acos'\r\n  , 'all'\r\n  , 'any'\r\n  , 'asin'\r\n  , 'atan'\r\n  , 'ceil'\r\n  , 'clamp'\r\n  , 'cos'\r\n  , 'cross'\r\n  , 'dFdx'\r\n  , 'dFdy'\r\n  , 'degrees'\r\n  , 'distance'\r\n  , 'dot'\r\n  , 'equal'\r\n  , 'exp'\r\n  , 'exp2'\r\n  , 'faceforward'\r\n  , 'floor'\r\n  , 'fract'\r\n  , 'gl_BackColor'\r\n  , 'gl_BackLightModelProduct'\r\n  , 'gl_BackLightProduct'\r\n  , 'gl_BackMaterial'\r\n  , 'gl_BackSecondaryColor'\r\n  , 'gl_ClipPlane'\r\n  , 'gl_ClipVertex'\r\n  , 'gl_Color'\r\n  , 'gl_DepthRange'\r\n  , 'gl_DepthRangeParameters'\r\n  , 'gl_EyePlaneQ'\r\n  , 'gl_EyePlaneR'\r\n  , 'gl_EyePlaneS'\r\n  , 'gl_EyePlaneT'\r\n  , 'gl_Fog'\r\n  , 'gl_FogCoord'\r\n  , 'gl_FogFragCoord'\r\n  , 'gl_FogParameters'\r\n  , 'gl_FragColor'\r\n  , 'gl_FragCoord'\r\n  , 'gl_FragData'\r\n  , 'gl_FragDepth'\r\n  , 'gl_FragDepthEXT'\r\n  , 'gl_FrontColor'\r\n  , 'gl_FrontFacing'\r\n  , 'gl_FrontLightModelProduct'\r\n  , 'gl_FrontLightProduct'\r\n  , 'gl_FrontMaterial'\r\n  , 'gl_FrontSecondaryColor'\r\n  , 'gl_LightModel'\r\n  , 'gl_LightModelParameters'\r\n  , 'gl_LightModelProducts'\r\n  , 'gl_LightProducts'\r\n  , 'gl_LightSource'\r\n  , 'gl_LightSourceParameters'\r\n  , 'gl_MaterialParameters'\r\n  , 'gl_MaxClipPlanes'\r\n  , 'gl_MaxCombinedTextureImageUnits'\r\n  , 'gl_MaxDrawBuffers'\r\n  , 'gl_MaxFragmentUniformComponents'\r\n  , 'gl_MaxLights'\r\n  , 'gl_MaxTextureCoords'\r\n  , 'gl_MaxTextureImageUnits'\r\n  , 'gl_MaxTextureUnits'\r\n  , 'gl_MaxVaryingFloats'\r\n  , 'gl_MaxVertexAttribs'\r\n  , 'gl_MaxVertexTextureImageUnits'\r\n  , 'gl_MaxVertexUniformComponents'\r\n  , 'gl_ModelViewMatrix'\r\n  , 'gl_ModelViewMatrixInverse'\r\n  , 'gl_ModelViewMatrixInverseTranspose'\r\n  , 'gl_ModelViewMatrixTranspose'\r\n  , 'gl_ModelViewProjectionMatrix'\r\n  , 'gl_ModelViewProjectionMatrixInverse'\r\n  , 'gl_ModelViewProjectionMatrixInverseTranspose'\r\n  , 'gl_ModelViewProjectionMatrixTranspose'\r\n  , 'gl_MultiTexCoord0'\r\n  , 'gl_MultiTexCoord1'\r\n  , 'gl_MultiTexCoord2'\r\n  , 'gl_MultiTexCoord3'\r\n  , 'gl_MultiTexCoord4'\r\n  , 'gl_MultiTexCoord5'\r\n  , 'gl_MultiTexCoord6'\r\n  , 'gl_MultiTexCoord7'\r\n  , 'gl_Normal'\r\n  , 'gl_NormalMatrix'\r\n  , 'gl_NormalScale'\r\n  , 'gl_ObjectPlaneQ'\r\n  , 'gl_ObjectPlaneR'\r\n  , 'gl_ObjectPlaneS'\r\n  , 'gl_ObjectPlaneT'\r\n  , 'gl_Point'\r\n  , 'gl_PointCoord'\r\n  , 'gl_PointParameters'\r\n  , 'gl_PointSize'\r\n  , 'gl_Position'\r\n  , 'gl_ProjectionMatrix'\r\n  , 'gl_ProjectionMatrixInverse'\r\n  , 'gl_ProjectionMatrixInverseTranspose'\r\n  , 'gl_ProjectionMatrixTranspose'\r\n  , 'gl_SecondaryColor'\r\n  , 'gl_TexCoord'\r\n  , 'gl_TextureEnvColor'\r\n  , 'gl_TextureMatrix'\r\n  , 'gl_TextureMatrixInverse'\r\n  , 'gl_TextureMatrixInverseTranspose'\r\n  , 'gl_TextureMatrixTranspose'\r\n  , 'gl_Vertex'\r\n  , 'greaterThan'\r\n  , 'greaterThanEqual'\r\n  , 'inversesqrt'\r\n  , 'length'\r\n  , 'lessThan'\r\n  , 'lessThanEqual'\r\n  , 'log'\r\n  , 'log2'\r\n  , 'matrixCompMult'\r\n  , 'max'\r\n  , 'min'\r\n  , 'mix'\r\n  , 'mod'\r\n  , 'normalize'\r\n  , 'not'\r\n  , 'notEqual'\r\n  , 'pow'\r\n  , 'radians'\r\n  , 'reflect'\r\n  , 'refract'\r\n  , 'sign'\r\n  , 'sin'\r\n  , 'smoothstep'\r\n  , 'sqrt'\r\n  , 'step'\r\n  , 'tan'\r\n  , 'texture2D'\r\n  , 'texture2DLod'\r\n  , 'texture2DProj'\r\n  , 'texture2DProjLod'\r\n  , 'textureCube'\r\n  , 'textureCubeLod'\r\n  , 'texture2DLodEXT'\r\n  , 'texture2DProjLodEXT'\r\n  , 'textureCubeLodEXT'\r\n  , 'texture2DGradEXT'\r\n  , 'texture2DProjGradEXT'\r\n  , 'textureCubeGradEXT'\r\n]\r\n", "var v100 = require('./literals')\r\n\r\nmodule.exports = v100.slice().concat([\r\n   'layout'\r\n  , 'centroid'\r\n  , 'smooth'\r\n  , 'case'\r\n  , 'mat2x2'\r\n  , 'mat2x3'\r\n  , 'mat2x4'\r\n  , 'mat3x2'\r\n  , 'mat3x3'\r\n  , 'mat3x4'\r\n  , 'mat4x2'\r\n  , 'mat4x3'\r\n  , 'mat4x4'\r\n  , 'uvec2'\r\n  , 'uvec3'\r\n  , 'uvec4'\r\n  , 'samplerCubeShadow'\r\n  , 'sampler2DArray'\r\n  , 'sampler2DArrayShadow'\r\n  , 'isampler2D'\r\n  , 'isampler3D'\r\n  , 'isamplerCube'\r\n  , 'isampler2DArray'\r\n  , 'usampler2D'\r\n  , 'usampler3D'\r\n  , 'usamplerCube'\r\n  , 'usampler2DArray'\r\n  , 'coherent'\r\n  , 'restrict'\r\n  , 'readonly'\r\n  , 'writeonly'\r\n  , 'resource'\r\n  , 'atomic_uint'\r\n  , 'noperspective'\r\n  , 'patch'\r\n  , 'sample'\r\n  , 'subroutine'\r\n  , 'common'\r\n  , 'partition'\r\n  , 'active'\r\n  , 'filter'\r\n  , 'image1D'\r\n  , 'image2D'\r\n  , 'image3D'\r\n  , 'imageCube'\r\n  , 'iimage1D'\r\n  , 'iimage2D'\r\n  , 'iimage3D'\r\n  , 'iimageCube'\r\n  , 'uimage1D'\r\n  , 'uimage2D'\r\n  , 'uimage3D'\r\n  , 'uimageCube'\r\n  , 'image1DArray'\r\n  , 'image2DArray'\r\n  , 'iimage1DArray'\r\n  , 'iimage2DArray'\r\n  , 'uimage1DArray'\r\n  , 'uimage2DArray'\r\n  , 'image1DShadow'\r\n  , 'image2DShadow'\r\n  , 'image1DArrayShadow'\r\n  , 'image2DArrayShadow'\r\n  , 'imageBuffer'\r\n  , 'iimageBuffer'\r\n  , 'uimageBuffer'\r\n  , 'sampler1DArray'\r\n  , 'sampler1DArrayShadow'\r\n  , 'isampler1D'\r\n  , 'isampler1DArray'\r\n  , 'usampler1D'\r\n  , 'usampler1DArray'\r\n  , 'isampler2DRect'\r\n  , 'usampler2DRect'\r\n  , 'samplerBuffer'\r\n  , 'isamplerBuffer'\r\n  , 'usamplerBuffer'\r\n  , 'sampler2DMS'\r\n  , 'isampler2DMS'\r\n  , 'usampler2DMS'\r\n  , 'sampler2DMSArray'\r\n  , 'isampler2DMSArray'\r\n  , 'usampler2DMSArray'\r\n])\r\n", "// 300es builtins/reserved words that were previously valid in v100\r\nvar v100 = require('./builtins')\r\n\r\n// The texture2D|Cube functions have been removed\r\n// And the gl_ features are updated\r\nv100 = v100.slice().filter(function (b) {\r\n  return !/^(gl\\_|texture)/.test(b)\r\n})\r\n\r\nmodule.exports = v100.concat([\r\n  // the updated gl_ constants\r\n    'gl_VertexID'\r\n  , 'gl_InstanceID'\r\n  , 'gl_Position'\r\n  , 'gl_PointSize'\r\n  , 'gl_FragCoord'\r\n  , 'gl_FrontFacing'\r\n  , 'gl_FragDepth'\r\n  , 'gl_PointCoord'\r\n  , 'gl_MaxVertexAttribs'\r\n  , 'gl_MaxVertexUniformVectors'\r\n  , 'gl_MaxVertexOutputVectors'\r\n  , 'gl_MaxFragmentInputVectors'\r\n  , 'gl_MaxVertexTextureImageUnits'\r\n  , 'gl_MaxCombinedTextureImageUnits'\r\n  , 'gl_MaxTextureImageUnits'\r\n  , 'gl_MaxFragmentUniformVectors'\r\n  , 'gl_MaxDrawBuffers'\r\n  , 'gl_MinProgramTexelOffset'\r\n  , 'gl_MaxProgramTexelOffset'\r\n  , 'gl_DepthRangeParameters'\r\n  , 'gl_DepthRange'\r\n\r\n  // other builtins\r\n  , 'trunc'\r\n  , 'round'\r\n  , 'roundEven'\r\n  , 'isnan'\r\n  , 'isinf'\r\n  , 'floatBitsToInt'\r\n  , 'floatBitsToUint'\r\n  , 'intBitsToFloat'\r\n  , 'uintBitsToFloat'\r\n  , 'packSnorm2x16'\r\n  , 'unpackSnorm2x16'\r\n  , 'packUnorm2x16'\r\n  , 'unpackUnorm2x16'\r\n  , 'packHalf2x16'\r\n  , 'unpackHalf2x16'\r\n  , 'outerProduct'\r\n  , 'transpose'\r\n  , 'determinant'\r\n  , 'inverse'\r\n  , 'texture'\r\n  , 'textureSize'\r\n  , 'textureProj'\r\n  , 'textureLod'\r\n  , 'textureOffset'\r\n  , 'texelFetch'\r\n  , 'texelFetchOffset'\r\n  , 'textureProjOffset'\r\n  , 'textureLodOffset'\r\n  , 'textureProjLod'\r\n  , 'textureProjLodOffset'\r\n  , 'textureGrad'\r\n  , 'textureGradOffset'\r\n  , 'textureProjGrad'\r\n  , 'textureProjGradOffset'\r\n])\r\n", "module.exports = tokenize\r\n\r\nvar literals100 = require('./lib/literals')\r\n  , operators = require('./lib/operators')\r\n  , builtins100 = require('./lib/builtins')\r\n  , literals300es = require('./lib/literals-300es')\r\n  , builtins300es = require('./lib/builtins-300es')\r\n\r\nvar NORMAL = 999          // <-- never emitted\r\n  , TOKEN = 9999          // <-- never emitted\r\n  , BLOCK_COMMENT = 0\r\n  , LINE_COMMENT = 1\r\n  , PREPROCESSOR = 2\r\n  , OPERATOR = 3\r\n  , INTEGER = 4\r\n  , FLOAT = 5\r\n  , IDENT = 6\r\n  , BUILTIN = 7\r\n  , KEYWORD = 8\r\n  , WHITESPACE = 9\r\n  , EOF = 10\r\n  , HEX = 11\r\n\r\nvar map = [\r\n    'block-comment'\r\n  , 'line-comment'\r\n  , 'preprocessor'\r\n  , 'operator'\r\n  , 'integer'\r\n  , 'float'\r\n  , 'ident'\r\n  , 'builtin'\r\n  , 'keyword'\r\n  , 'whitespace'\r\n  , 'eof'\r\n  , 'integer'\r\n]\r\n\r\nfunction tokenize(opt) {\r\n  var i = 0\r\n    , total = 0\r\n    , mode = NORMAL\r\n    , c\r\n    , last\r\n    , content = []\r\n    , tokens = []\r\n    , token_idx = 0\r\n    , token_offs = 0\r\n    , line = 1\r\n    , col = 0\r\n    , start = 0\r\n    , isnum = false\r\n    , isoperator = false\r\n    , input = ''\r\n    , len\r\n\r\n  opt = opt || {}\r\n  var allBuiltins = builtins100\r\n  var allLiterals = literals100\r\n  if (opt.version === '300 es') {\r\n    allBuiltins = builtins300es\r\n    allLiterals = literals300es\r\n  }\r\n\r\n  // cache by name\r\n  var builtinsDict = {}, literalsDict = {}\r\n  for (var i = 0; i < allBuiltins.length; i++) {\r\n    builtinsDict[allBuiltins[i]] = true\r\n  }\r\n  for (var i = 0; i < allLiterals.length; i++) {\r\n    literalsDict[allLiterals[i]] = true\r\n  }\r\n\r\n  return function(data) {\r\n    tokens = []\r\n    if (data !== null) return write(data)\r\n    return end()\r\n  }\r\n\r\n  function token(data) {\r\n    if (data.length) {\r\n      tokens.push({\r\n        type: map[mode]\r\n      , data: data\r\n      , position: start\r\n      , line: line\r\n      , column: col\r\n      })\r\n    }\r\n  }\r\n\r\n  function write(chunk) {\r\n    i = 0\r\n\r\n    if (chunk.toString) chunk = chunk.toString()\r\n\r\n    input += chunk.replace(/\\r\\n/g, '\\n')\r\n    len = input.length\r\n\r\n\r\n    var last\r\n\r\n    while(c = input[i], i < len) {\r\n      last = i\r\n\r\n      switch(mode) {\r\n        case BLOCK_COMMENT: i = block_comment(); break\r\n        case LINE_COMMENT: i = line_comment(); break\r\n        case PREPROCESSOR: i = preprocessor(); break\r\n        case OPERATOR: i = operator(); break\r\n        case INTEGER: i = integer(); break\r\n        case HEX: i = hex(); break\r\n        case FLOAT: i = decimal(); break\r\n        case TOKEN: i = readtoken(); break\r\n        case WHITESPACE: i = whitespace(); break\r\n        case NORMAL: i = normal(); break\r\n      }\r\n\r\n      if(last !== i) {\r\n        switch(input[last]) {\r\n          case '\\n': col = 0; ++line; break\r\n          default: ++col; break\r\n        }\r\n      }\r\n    }\r\n\r\n    total += i\r\n    input = input.slice(i)\r\n    return tokens\r\n  }\r\n\r\n  function end(chunk) {\r\n    if(content.length) {\r\n      token(content.join(''))\r\n    }\r\n\r\n    mode = EOF\r\n    token('(eof)')\r\n    return tokens\r\n  }\r\n\r\n  function normal() {\r\n    content = content.length ? [] : content\r\n\r\n    if(last === '/' && c === '*') {\r\n      start = total + i - 1\r\n      mode = BLOCK_COMMENT\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(last === '/' && c === '/') {\r\n      start = total + i - 1\r\n      mode = LINE_COMMENT\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(c === '#') {\r\n      mode = PREPROCESSOR\r\n      start = total + i\r\n      return i\r\n    }\r\n\r\n    if(/\\s/.test(c)) {\r\n      mode = WHITESPACE\r\n      start = total + i\r\n      return i\r\n    }\r\n\r\n    isnum = /\\d/.test(c)\r\n    isoperator = /[^\\w_]/.test(c)\r\n\r\n    start = total + i\r\n    mode = isnum ? INTEGER : isoperator ? OPERATOR : TOKEN\r\n    return i\r\n  }\r\n\r\n  function whitespace() {\r\n    if(/[^\\s]/g.test(c)) {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function preprocessor() {\r\n    if((c === '\\r' || c === '\\n') && last !== '\\\\') {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function line_comment() {\r\n    return preprocessor()\r\n  }\r\n\r\n  function block_comment() {\r\n    if(c === '/' && last === '*') {\r\n      content.push(c)\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i + 1\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function operator() {\r\n    if(last === '.' && /\\d/.test(c)) {\r\n      mode = FLOAT\r\n      return i\r\n    }\r\n\r\n    if(last === '/' && c === '*') {\r\n      mode = BLOCK_COMMENT\r\n      return i\r\n    }\r\n\r\n    if(last === '/' && c === '/') {\r\n      mode = LINE_COMMENT\r\n      return i\r\n    }\r\n\r\n    if(c === '.' && content.length) {\r\n      while(determine_operator(content));\r\n\r\n      mode = FLOAT\r\n      return i\r\n    }\r\n\r\n    if(c === ';' || c === ')' || c === '(') {\r\n      if(content.length) while(determine_operator(content));\r\n      token(c)\r\n      mode = NORMAL\r\n      return i + 1\r\n    }\r\n\r\n    var is_composite_operator = content.length === 2 && c !== '='\r\n    if(/[\\w_\\d\\s]/.test(c) || is_composite_operator) {\r\n      while(determine_operator(content));\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function determine_operator(buf) {\r\n    var j = 0\r\n      , idx\r\n      , res\r\n\r\n    do {\r\n      idx = operators.indexOf(buf.slice(0, buf.length + j).join(''))\r\n      res = operators[idx]\r\n\r\n      if(idx === -1) {\r\n        if(j-- + buf.length > 0) continue\r\n        res = buf.slice(0, 1).join('')\r\n      }\r\n\r\n      token(res)\r\n\r\n      start += res.length\r\n      content = content.slice(res.length)\r\n      return content.length\r\n    } while(1)\r\n  }\r\n\r\n  function hex() {\r\n    if(/[^a-fA-F0-9]/.test(c)) {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function integer() {\r\n    if(c === '.') {\r\n      content.push(c)\r\n      mode = FLOAT\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(/[eE]/.test(c)) {\r\n      content.push(c)\r\n      mode = FLOAT\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(c === 'x' && content.length === 1 && content[0] === '0') {\r\n      mode = HEX\r\n      content.push(c)\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(/[^\\d]/.test(c)) {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function decimal() {\r\n    if(c === 'f') {\r\n      content.push(c)\r\n      last = c\r\n      i += 1\r\n    }\r\n\r\n    if(/[eE]/.test(c)) {\r\n      content.push(c)\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if ((c === '-' || c === '+') && /[eE]/.test(last)) {\r\n      content.push(c)\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(/[^\\d]/.test(c)) {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function readtoken() {\r\n    if(/[^\\d\\w_]/.test(c)) {\r\n      var contentstr = content.join('')\r\n      if(literalsDict[contentstr]) {\r\n        mode = KEYWORD\r\n      } else if(builtinsDict[contentstr]) {\r\n        mode = BUILTIN\r\n      } else {\r\n        mode = IDENT\r\n      }\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n}\r\n", "var tokenize = require('./index')\r\n\r\nmodule.exports = tokenizeString\r\n\r\nfunction tokenizeString(str, opt) {\r\n  var generator = tokenize(opt)\r\n  var tokens = []\r\n\r\n  tokens = tokens.concat(generator(str))\r\n  tokens = tokens.concat(generator(null))\r\n\r\n  return tokens\r\n}\r\n", "module.exports = getTokenDepth\n\nfunction getTokenDepth(tokens) {\n  var loop  = false\n  var depth = 0\n\n  for (var i = 0; i < tokens.length; i++) {\n    loop = loop || (tokens[i].type === 'keyword' && (\n      tokens[i].data === 'for'\n    ))\n\n    switch (tokens[i].data) {\n      case '(': tokens[i].depth = loop ? depth++ : depth; break\n      case '{': tokens[i].depth = loop ? depth : depth++; loop = false; break\n      case '}': tokens[i].depth = --depth; break\n      default:  tokens[i].depth = depth\n    }\n  }\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n    var index = i + 1\n    if (token.type !== 'ident' && token.type !== 'keyword') continue\n    skipArrayArguments()\n    if (tokens[index].type !== 'ident') continue\n    skipArrayArguments()\n    index++\n    if (tokens[index].data !== '(') continue\n\n    while (tokens[index] && tokens[index].data !== ';' && tokens[index].data !== '{') {\n      tokens[index++].depth++\n    }\n    if (tokens[index] && tokens[index].data === '{') tokens[index].depth++\n  }\n\n  return tokens\n\n  function skipArrayArguments() {\n    while (tokens[index] && (\n      tokens[index].type === 'whitespace' ||\n      tokens[index].data === '[' ||\n      tokens[index].data === ']' ||\n      tokens[index].data === 'integer'\n    )) index++\n  }\n}\n", "module.exports = tokenScope\n\nfunction tokenScope(tokens) {\n  var stack  = [0]\n  var inc    = stack[0]\n  var ldepth = 0\n\n  if (!tokens || !tokens.length) return tokens\n  if (!('depth' in tokens[0])) {\n    throw new Error('glsl-token-scope: No scope depth defined on tokens! Use glsl-token-depth on these tokens first')\n  }\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n    var depth = token.depth\n\n    if (depth > ldepth) {\n      stack.push(++inc)\n    } else\n    if (depth < ldepth) {\n      stack.splice(-1, 1)\n    }\n\n    token.scope = stack[stack.length - 1]\n    token.stack = stack.slice()\n    ldepth = token.depth\n  }\n\n  return tokens\n}\n", "module.exports = properties\n\nfunction properties(tokens) {\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n    token.property = false\n\n    if (token.type !== 'ident') continue\n\n    var j = i\n    while (tokens[--j] && tokens[j].type === 'whitespace');\n    if (!tokens[j]) continue\n    if (tokens[j].type !== 'operator') continue\n    if (tokens[j].data !== '.') continue\n\n    token.property = true\n  }\n\n  return tokens\n}\n", "module.exports = {\n    '<<=': true\n  , '>>=': true\n  , '++': true\n  , '--': true\n  , '+=': true\n  , '-=': true\n  , '*=': true\n  , '/=': true\n  , '%=': true\n  , '&=': true\n  , '^=': true\n  , '|=': true\n  , '=': true\n}\n", "module.exports = {\n    'precision': true\n  , 'highp': true\n  , 'mediump': true\n  , 'lowp': true\n  , 'attribute': true\n  , 'const': true\n  , 'uniform': true\n  , 'varying': true\n  , 'break': true\n  , 'continue': true\n  , 'do': true\n  , 'for': true\n  , 'while': true\n  , 'if': true\n  , 'else': true\n  , 'in': true\n  , 'out': true\n  , 'inout': true\n  , 'true': true\n  , 'false': true\n  , 'return': true\n}\n", "var assignments = require('./assignments')\nvar ignoredKeywords = require('./ignored')\n\nmodule.exports = assigns\n\n// Here be dragons. Apologies in advance for the hairy code!\nfunction assigns(tokens) {\n  var idx = 0\n\n  // Determine if a value has been assigned, e.g.\n  // x = 1.0;\n  // float x = 1.0;\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n    var type  = token.type\n\n    token.assignment = false\n    token.declaration = false\n    if (type !== 'ident' && type !== 'builtin') continue\n    idx = i + 1\n\n    skipWhitespace(+1)\n    if (tokens[idx].type !== 'operator') continue\n    if (!assignments[tokens[idx].data]) continue\n    token.assignment = true\n  }\n\n  // Determine if a value is being defined, e.g.\n  // float x;\n  // float x, y, z;\n  // float x, y = vec3(sin(1.0 + 3.0)), z;\n  // float[3][2] x, y = vec3(sin(1.0 + 3.0)), z;\n  // float[][2] x, y = vec3(sin(1.0 + 3.0)), z;\n  // float x[2], y = vec3(sin(1.0 + 3.0)), z[4];\n  // float x(float y, float z) {};\n  // float x(float y[2], Thing[3] z) {};\n  // Thing x[2], y = Another(sin(1.0 + 3.0)), z[4];\n  for (var i = 0; i < tokens.length; i++) {\n    var datatype = tokens[i]\n    var type     = datatype.type\n    var data     = datatype.data\n\n    datatype.declaration = false\n\n    if (type === 'keyword') {\n      if (ignoredKeywords[data]) continue\n    } else\n    if (type !== 'ident') continue\n\n    idx = i + 1\n\n    skipArrayDimensions()\n    if (tokens[idx].type !== 'ident') continue\n    tokens[idx++].declaration = true\n    skipArrayDimensions()\n\n    // Function arguments/parameters\n    if (tokens[idx].data === '(') {\n      idx++\n\n      skipWhitespace(+1)\n      while (tokens[idx] && tokens[idx].data !== ')') {\n        if (tokens[idx].type !== 'keyword' && tokens[idx].type !== 'ident') break\n        idx++\n        skipWhitespace(+1)\n        if (tokens[idx].type !== 'ident') continue\n        tokens[idx++].declaration = true\n        skipWhitespace(+1)\n        skipArrayDimensions()\n        skipWhitespace(+1)\n        if (tokens[idx].data !== ',') continue\n        idx++\n        skipWhitespace(+1)\n      }\n\n      i = idx\n      continue\n    }\n\n    // Declaration Lists\n    while (tokens[idx] && tokens[idx].data !== ';') {\n      if (tokens[idx].data === ',') {\n        idx++\n        skipWhitespace(+1)\n        if (tokens[idx].declaration = tokens[idx].type === 'ident') idx++\n      } else {\n        skipWhitespace(+1)\n        skipParens()\n        skipWhitespace(+1)\n        idx++\n      }\n    }\n\n    i = idx\n  }\n\n  // Handle struct declarations:\n  // struct declaration {\n  //   float x, y, z;\n  //   Other w;\n  // } declaration;\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n    if (token.type !== 'keyword') continue\n    if (token.data !== 'struct') continue\n    idx = i + 1\n    skipWhitespace(+1)\n    if (tokens[idx].type !== 'ident') continue\n\n    idx++\n    skipWhitespace(+1)\n    if (tokens[idx++].data !== '{') continue\n    skipWhitespace(+1)\n\n    while (tokens[idx].type === 'ident' || tokens[idx].type === 'keyword') {\n      do {\n        idx++\n        skipWhitespace(+1)\n        tokens[idx].structMember = true\n        tokens[idx].declaration = false\n        idx++\n        skipArrayDimensions()\n      } while (tokens[idx].data === ',')\n\n      if (tokens[idx].data === ';') idx++\n      skipWhitespace()\n    }\n\n    idx++\n    skipWhitespace(+1)\n    if (tokens[idx].type !== 'ident') continue\n    tokens[idx].declaration = true\n    skipWhitespace(+1)\n\n    while (tokens[++idx].data === ',') {\n      skipWhitespace(+1)\n      idx++\n      skipWhitespace(+1)\n      if (tokens[idx].type === 'ident') tokens[idx].declaration = true\n      skipWhitespace(+1)\n    }\n  }\n\n  return tokens\n\n  function skipWhitespace(n) {\n    while (tokens[idx] && tokens[idx].type === 'whitespace') idx++\n  }\n\n  function skipArrayDimensions() {\n    while (tokens[idx] && (\n         tokens[idx].type === 'integer'\n      || tokens[idx].data === '['\n      || tokens[idx].data === ']'\n      || tokens[idx].type === 'whitespace'\n    )) idx++\n  }\n\n  function skipParens() {\n    if (!tokens[idx]) return\n    if (tokens[idx].data !== '(') return\n    var depth = 0\n    var a = idx\n    do {\n      if (tokens[idx].data === ';') break\n      if (tokens[idx].data === '(') depth++\n      if (tokens[idx].data === ')') depth--\n    } while(depth && tokens[++idx])\n  }\n}\n", "module.exports = glslTokenDescope\n\nfunction glslTokenDescope(tokens, rename) {\n  require('glsl-token-depth')(tokens)\n  require('glsl-token-scope')(tokens)\n  require('glsl-token-properties')(tokens)\n  require('glsl-token-assignments')(tokens)\n\n  var scope   = getScope(tokens)\n  var renamer = rename || defaultRenamer()\n  var map     = {}\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n    var stack = token.stack\n    var name  = token.data\n\n    token.descoped = false\n\n    if (token.type !== 'ident') continue\n    if (token.property) continue\n    if (token.structMember) continue\n\n    var bound = false\n\n    for (var j = stack.length - 1; j >= 0; j--) {\n      var s = scope[stack[j]]\n      if (!s) continue\n      if (!s[name]) continue\n\n      bound = true\n\n      // exit if declaration not in top-level scope\n      if (j) break\n\n      token.descoped = token.data\n      token.data = map[name] = map[name] || renamer(name, token) || token.data\n    }\n\n    // Handle unbound variables, i.e. ones not defined anywhere\n    // in the shader source but still used.\n    if (!bound) {\n      token.descoped = token.data\n      token.data = map[name] = map[name] || renamer(name, token) || token.data\n    }\n  }\n\n  return tokens\n}\n\nfunction defaultRenamer() {\n  var k = 0\n\n  return function rename(name) {\n    return name + '_' + (k++).toString(36)\n  }\n}\n\nfunction getScope(tokens) {\n  var scope = {}\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n    if (token.declaration) {\n      scope[token.scope] = scope[token.scope] || {}\n      scope[token.scope][token.data] = token\n    }\n  }\n\n  return scope\n}\n", "module.exports = toString\n\nfunction toString(tokens) {\n  var output = []\n\n  for (var i = 0; i < tokens.length; i++) {\n    if (tokens[i].type === 'eof') continue\n    output.push(tokens[i].data)\n  }\n\n  return output.join('')\n}\n", "module.exports = functions\n\nfunction functions (tokens) {\n  var returnType = null\n  var defnName = null\n  var braceDepth = 0\n  var braceStart = 0\n  var defnStart = 0\n  var argFinish = 0\n  var argStart = 0\n  var output = []\n  var i, j, token\n\n  // The following loop detects functions with bodies of any type,\n  // including structs. e.g.\n  // void main() {...}\n  // vec4 fn(vec3 a) {...}\n  // Ray3 fn(vec3 ro, vec3 rd) {...}\n  for (i = 0, j; i < tokens.length; i++) {\n    token = tokens[i]\n    if (token.data === '{') {\n      // If already in a function, keep track of opening braces\n      if (braceDepth && braceDepth++) continue\n\n      // Stepping backwards from the closing brace, find the end\n      // of the arguments list. There should only be whitespace on\n      // the way there.\n      j = findPrevious(i, findOp(')'), findOp())\n      if (j < 0) continue\n      argFinish = j\n\n      // Step backwards to find the beginning of the arguments list. If there's\n      // a nested paranthesis in there, then it's definitely not a function.\n      j = findPrevious(j, findOp('('), findOp(')'))\n      if (j < 0) continue\n      argStart = j\n\n      // Continue stepping backwards past any whitespace to find the\n      // function name. If the token isn't an identifier then it's not a\n      // function so we bail\n      j = findPrevious(j, findGlyph)\n      if (j < 0) continue\n      if (tokens[j].type !== 'ident') continue\n      defnName = tokens[j].data\n\n      // The next non-whitespace token should be the return type of\n      // the function\n      j = findPrevious(j, findGlyph)\n      if (j < 0) continue\n\n      braceDepth = 1\n      braceStart = i\n      returnType = tokens[j].data\n      defnStart = j\n\n      // There are cases when a function definition includes a\n      // precision qualifier, e.g. highp float random();\n      // So we backtrack one extra step to check if that's the\n      // case, and handle it :)\n      var k = findPrevious(j, findGlyph)\n      switch (tokens[k] && tokens[k].data) {\n        case 'lowp':\n        case 'highp':\n        case 'mediump':\n          defnStart = k\n      }\n    } else\n    if (braceDepth && token.data === '}') {\n      if (--braceDepth) continue\n\n      output.push({\n        name: defnName,\n        type: returnType,\n        body: [braceStart + 1, i],\n        args: [argStart, argFinish + 1],\n        outer: [defnStart, i + 1]\n      })\n    }\n  }\n\n  // This loop is for handling the edge case of functions defined\n  // without a body. Generally, this body is defined later in the file.\n  // void main();\n  // vec2 doModel(vec3 p);\n  // Note the replacement of curly braces with a semicolon.\n  for (i = 0; i < tokens.length; i++) {\n    token = tokens[i]\n    if (token.data === ';') {\n      // Like before, we start from a semicolon and find the\n      // bounds of the argument list to find the function name\n      j = findPrevious(i, findOp(')'), findOp())\n      if (j < 0) continue\n      argFinish = j\n      j = findPrevious(j, findOp('('), findOp(')'))\n      if (j < 0) continue\n      argStart = j\n      j = findPrevious(j, findGlyph)\n      if (j < 0) continue\n      if (tokens[j].type !== 'ident') continue\n      defnName = tokens[j].data\n\n      // Try and find an ident or builtin character, which should be\n      // our return type. If so, it'll be the very first preceding glyph.\n      j = findPrevious(j, findGlyph)\n      if (j < 0) continue\n      if (tokens[j].type === 'operator') continue\n      if (tokens[j].data === 'return') continue\n      returnType = tokens[j].data\n\n      output.push({\n        name: defnName,\n        type: returnType,\n        body: false,\n        args: [argStart, argFinish + 1],\n        outer: [j, i + 1]\n      })\n    }\n  }\n\n  return output.sort(function (a, b) {\n    return a.outer[0] - b.outer[0]\n  })\n\n  function findPrevious (start, match, bail) {\n    for (var i = start - 1; i >= 0; i--) {\n      if (match(tokens[i])) return i\n      if (bail && bail(tokens[i])) return -1\n    }\n\n    return -1\n  }\n}\n\nfunction findOp (data) {\n  return function (token) {\n    return token.type === 'operator' && (!data || token.data === data)\n  }\n}\n\nfunction findGlyph (token) {\n  return token.type !== 'whitespace'\n}\n", "import * as THREE from 'three'\r\nimport { Abstract } from './vanilla'\r\n\r\nexport const BlendModes: {\r\n  [key: string]: string\r\n} = {\r\n  normal: 'normal',\r\n  add: 'add',\r\n  subtract: 'subtract',\r\n  multiply: 'multiply',\r\n  lighten: 'lighten',\r\n  darken: 'darken',\r\n  divide: 'divide',\r\n  overlay: 'overlay',\r\n  screen: 'screen',\r\n  softlight: 'softlight',\r\n  negation: 'negation',\r\n  reflect: 'reflect',\r\n}\r\n\r\nexport type BlendMode =\r\n  | 'normal'\r\n  | 'add'\r\n  | 'subtract'\r\n  | 'multiply'\r\n  | 'lighten'\r\n  | 'darken'\r\n  | 'divide'\r\n  | 'overlay'\r\n  | 'screen'\r\n  | 'softlight'\r\n  | 'reflect'\r\n  | 'negation'\r\n\r\nexport const NoiseTypes: {\r\n  [key: string]: string\r\n} = {\r\n  perlin: 'perlin',\r\n  simplex: 'simplex',\r\n  cell: 'cell',\r\n  curl: 'curl',\r\n  white: 'white',\r\n}\r\n\r\nexport type NoiseType = 'perlin' | 'simplex' | 'cell' | 'curl' | 'white'\r\n\r\nexport const MappingTypes: {\r\n  [key: string]: string\r\n} = {\r\n  local: 'local',\r\n  world: 'world',\r\n  uv: 'uv',\r\n}\r\n\r\nexport type MappingType = 'local' | 'world' | 'uv'\r\n\r\nexport const ShadingTypes: {\r\n  [key: string]: new () => THREE.Material\r\n} = {\r\n  phong: THREE.MeshPhongMaterial,\r\n  physical: THREE.MeshPhysicalMaterial,\r\n  toon: THREE.MeshToonMaterial,\r\n  basic: THREE.MeshBasicMaterial,\r\n  lambert: THREE.MeshLambertMaterial,\r\n  standard: THREE.MeshStandardMaterial,\r\n}\r\n\r\nexport type ShadingType = 'phong' | 'physical' | 'toon' | 'basic' | 'lambert' | 'standard'\r\n\r\nexport interface BaseProps {\r\n  color?: THREE.ColorRepresentation | THREE.Color\r\n  alpha?: number\r\n  name?: string\r\n}\r\n\r\nexport interface LayerMaterialParameters {\r\n  layers?: Abstract[]\r\n  color?: THREE.ColorRepresentation | THREE.Color\r\n  alpha?: number\r\n  lighting?: ShadingType\r\n  name?: string\r\n}\r\nexport type LayerMaterialProps = Omit<LayerMaterialParameters, 'layers'>\r\n\r\nexport interface LayerProps {\r\n  mode?: BlendMode\r\n  name?: string\r\n  visible?: boolean\r\n  [key: string]: any\r\n}\r\n\r\nexport interface ColorProps extends LayerProps {\r\n  color?: THREE.ColorRepresentation | THREE.Color\r\n  alpha?: number\r\n}\r\nexport interface NormalProps extends LayerProps {\r\n  direction?: THREE.Vector3 | [number, number, number]\r\n  alpha?: number\r\n}\r\n\r\nexport interface DepthProps extends LayerProps {\r\n  colorA?: THREE.ColorRepresentation | THREE.Color\r\n  colorB?: THREE.ColorRepresentation | THREE.Color\r\n  alpha?: number\r\n  near?: number\r\n  far?: number\r\n  origin?: THREE.Vector3 | [number, number, number]\r\n  mapping?: 'vector' | 'world' | 'camera'\r\n}\r\n\r\nexport interface NoiseProps extends LayerProps {\r\n  colorA?: THREE.ColorRepresentation | THREE.Color\r\n  colorB?: THREE.ColorRepresentation | THREE.Color\r\n  colorC?: THREE.ColorRepresentation | THREE.Color\r\n  colorD?: THREE.ColorRepresentation | THREE.Color\r\n  alpha?: number\r\n  mapping?: MappingType\r\n  type?: NoiseType\r\n  scale?: number\r\n  offset?: THREE.Vector3 | [number, number, number]\r\n}\r\nexport interface DisplaceProps extends LayerProps {\r\n  strength?: number\r\n  scale?: number\r\n  mapping?: MappingType\r\n  type?: NoiseType\r\n  offset?: THREE.Vector3 | [number, number, number]\r\n}\r\n\r\nexport interface FresnelProps extends LayerProps {\r\n  color?: THREE.ColorRepresentation | THREE.Color\r\n  alpha?: number\r\n  power?: number\r\n  intensity?: number\r\n  bias?: number\r\n}\r\nexport interface GradientProps extends LayerProps {\r\n  colorA?: THREE.ColorRepresentation | THREE.Color\r\n  colorB?: THREE.ColorRepresentation | THREE.Color\r\n  axes?: 'x' | 'y' | 'z'\r\n  alpha?: number\r\n  contrast?: number\r\n  start?: number\r\n  end?: number\r\n  mapping?: MappingType\r\n}\r\n\r\nexport interface MatcapProps extends LayerProps {\r\n  map?: THREE.Texture\r\n  alpha?: number\r\n}\r\nexport interface TextureProps extends LayerProps {\r\n  map?: THREE.Texture\r\n  alpha?: number\r\n}\r\n\r\nexport interface SerializedLayer {\r\n  constructor: string\r\n  properties: {\r\n    [name: string]: any\r\n  }\r\n}\r\n", "import { Color, Matrix3, Matrix4, Texture, Vector2, Vector3, Vector4 } from 'three'\r\nimport { LayerMaterialProps } from '../types'\r\n\r\nexport function getUniform(value: any) {\r\n  if (typeof value === 'string') {\r\n    return new Color(value).convertLinearToSRGB()\r\n  }\r\n\r\n  return value\r\n}\r\n\r\nexport function getSpecialParameters(label: string) {\r\n  switch (label) {\r\n    case 'alpha':\r\n      return {\r\n        min: 0,\r\n        max: 1,\r\n      }\r\n    case 'scale':\r\n      return {\r\n        min: 0,\r\n      }\r\n\r\n    case 'map':\r\n      return {\r\n        image: undefined,\r\n      }\r\n\r\n    default:\r\n      return {}\r\n  }\r\n}\r\n\r\nexport function getLayerMaterialArgs({ color, alpha, lighting, name, ...rest }: LayerMaterialProps & any = {}) {\r\n  return [\r\n    {\r\n      color,\r\n      alpha,\r\n      lighting,\r\n      name,\r\n    },\r\n    rest,\r\n  ] as any\r\n}\r\n\r\nexport function isSerializableType(prop: any) {\r\n  return (\r\n    prop instanceof Vector3 ||\r\n    prop instanceof Vector2 ||\r\n    prop instanceof Vector4 ||\r\n    prop instanceof Matrix3 ||\r\n    prop instanceof Matrix4\r\n  )\r\n}\r\n\r\nexport function serializeProp(prop: any) {\r\n  if (isSerializableType(prop)) {\r\n    return prop.toArray()\r\n  } else if (prop instanceof Color) {\r\n    return '#' + prop.clone().convertLinearToSRGB().getHexString()\r\n  } else if (prop instanceof Texture) {\r\n    return prop.image.src\r\n  }\r\n\r\n  return prop\r\n}\r\n", "import { Color, IUniform, MathUtils } from 'three'\r\nimport { BlendMode, BlendModes, LayerProps, SerializedLayer } from '../types'\r\nimport { getSpecialParameters, getUniform, isSerializableType, serializeProp } from '../utils/Functions'\r\n\r\n// @ts-ignore\r\nimport tokenize from 'glsl-tokenizer'\r\n// @ts-ignore\r\nimport descope from 'glsl-token-descope'\r\n// @ts-ignore\r\nimport stringify from 'glsl-token-string'\r\n// @ts-ignore\r\nimport tokenFunctions from 'glsl-token-functions'\r\n\r\nexport default class Abstract {\r\n  uuid: string = MathUtils.generateUUID().replace(/-/g, '_')\r\n  name: string = 'LayerMaterial'\r\n  mode: BlendMode = 'normal'\r\n  visible: boolean = true\r\n  uniforms: {\r\n    [key: string]: IUniform<any>\r\n  }\r\n\r\n  onParse?: (self: Abstract & any) => void\r\n\r\n  fragmentShader: string\r\n  vertexShader: string\r\n  vertexVariables: string\r\n  fragmentVariables: string\r\n\r\n  schema: {\r\n    value: any\r\n    label: any\r\n    options?: any[]\r\n  }[]\r\n\r\n  constructor(c: new () => Abstract, props?: LayerProps | null, onParse?: (self: Abstract & any) => void) {\r\n    const defaults = Object.getOwnPropertyNames(c).filter((e) => e.startsWith('u_'))\r\n    const uniforms: { [key: string]: any } = defaults.reduce((a, v) => {\r\n      let value = Object.getOwnPropertyDescriptor(c, v)?.value\r\n\r\n      if (isSerializableType(value) || value instanceof Color) value = value.clone()\r\n\r\n      return {\r\n        ...a,\r\n        [v.slice(1)]: value,\r\n      }\r\n    }, {})\r\n\r\n    for (const key in uniforms) {\r\n      const propName = key.split('_')[1]\r\n      if (props?.[propName] !== undefined) uniforms[key] = props[propName]\r\n    }\r\n\r\n    if (props) {\r\n      Object.keys(props).map((key) => {\r\n        if (props[key] !== undefined) {\r\n          // @ts-ignore\r\n          this[key] = props[key]\r\n        }\r\n      })\r\n    }\r\n\r\n    this.uniforms = {}\r\n    this.schema = []\r\n    const properties: PropertyDescriptorMap & ThisType<any> = {}\r\n    Object.keys(uniforms).map((key) => {\r\n      const propName = key.split('_')[1]\r\n\r\n      this.uniforms[`u_${this.uuid}_${propName}`] = {\r\n        value: getUniform(uniforms[key]),\r\n      }\r\n\r\n      this.schema.push({\r\n        value: uniforms[key],\r\n        label: propName,\r\n      })\r\n\r\n      properties[propName] = {\r\n        set: (v: any) => {\r\n          this.uniforms[`u_${this.uuid}_${propName}`].value = getUniform(v)\r\n        },\r\n        get: () => {\r\n          return this.uniforms[`u_${this.uuid}_${propName}`].value\r\n        },\r\n      }\r\n    })\r\n\r\n    if (props?.name) this.name = props.name\r\n    if (props?.mode) this.mode = props.mode\r\n    if (props?.visible) this.visible = props.visible\r\n\r\n    Object.defineProperties(this, properties)\r\n\r\n    this.vertexShader = ''\r\n    this.fragmentShader = ''\r\n    this.vertexVariables = ''\r\n    this.fragmentVariables = ''\r\n    this.onParse = onParse\r\n\r\n    this.buildShaders(c)\r\n\r\n    // Remove Name field from Debugger until a way to\r\n    // rename Leva folders is found\r\n    // this.schema.push({\r\n    //   value: this.name,\r\n    //   label: 'name',\r\n    // })\r\n    this.schema.push({\r\n      value: this.mode,\r\n      label: 'mode',\r\n      options: Object.values(BlendModes),\r\n    })\r\n    this.schema.push({\r\n      value: this.visible,\r\n      label: 'visible',\r\n    })\r\n  }\r\n\r\n  buildShaders(constructor: any) {\r\n    const shaders = Object.getOwnPropertyNames(constructor)\r\n      .filter((e) => e === 'fragmentShader' || e === 'vertexShader')\r\n      .reduce(\r\n        (a, v) => ({\r\n          ...a,\r\n          [v]: Object.getOwnPropertyDescriptor(constructor, v)?.value,\r\n        }),\r\n        {}\r\n      ) as {\r\n      fragmentShader: string\r\n      vertexShader: string\r\n    }\r\n\r\n    const tokens = {\r\n      vert: tokenize(shaders.vertexShader || ''),\r\n      frag: tokenize(shaders.fragmentShader || ''),\r\n    }\r\n\r\n    const descoped = {\r\n      vert: descope(tokens.vert, this.renameTokens.bind(this)),\r\n      frag: descope(tokens.frag, this.renameTokens.bind(this)),\r\n    }\r\n\r\n    const funcs = {\r\n      vert: tokenFunctions(descoped.vert),\r\n      frag: tokenFunctions(descoped.frag),\r\n    }\r\n\r\n    const mainIndex = {\r\n      vert: funcs.vert\r\n        .map((e: any) => {\r\n          return e.name\r\n        })\r\n        .indexOf('main'),\r\n      frag: funcs.frag\r\n        .map((e: any) => {\r\n          return e.name\r\n        })\r\n        .indexOf('main'),\r\n    }\r\n\r\n    const variables = {\r\n      vert: mainIndex.vert >= 0 ? stringify(descoped.vert.slice(0, funcs.vert[mainIndex.vert].outer[0])) : '',\r\n      frag: mainIndex.frag >= 0 ? stringify(descoped.frag.slice(0, funcs.frag[mainIndex.frag].outer[0])) : '',\r\n    }\r\n\r\n    const funcBodies = {\r\n      vert: mainIndex.vert >= 0 ? this.getShaderFromIndex(descoped.vert, funcs.vert[mainIndex.vert].body) : '',\r\n      frag: mainIndex.frag >= 0 ? this.getShaderFromIndex(descoped.frag, funcs.frag[mainIndex.frag].body) : '',\r\n    }\r\n\r\n    this.vertexShader = this.processFinal(funcBodies.vert, true)\r\n    this.fragmentShader = this.processFinal(funcBodies.frag)\r\n    this.vertexVariables = variables.vert\r\n    this.fragmentVariables = variables.frag\r\n\r\n    this.onParse?.(this)\r\n    this.schema = this.schema.filter((value, index) => {\r\n      const _value = value.label\r\n      return (\r\n        index ===\r\n        this.schema.findIndex((obj) => {\r\n          return obj.label === _value\r\n        })\r\n      )\r\n    })\r\n  }\r\n\r\n  renameTokens(name: string) {\r\n    if (name.startsWith('u_')) {\r\n      const slice = name.slice(2)\r\n      return `u_${this.uuid}_${slice}`\r\n    } else if (name.startsWith('v_')) {\r\n      const slice = name.slice(2)\r\n      return `v_${this.uuid}_${slice}`\r\n    } else if (name.startsWith('f_')) {\r\n      const slice = name.slice(2)\r\n      return `f_${this.uuid}_${slice}`\r\n    } else {\r\n      return name\r\n    }\r\n  }\r\n\r\n  processFinal(shader: string, isVertex?: boolean) {\r\n    const s: string = shader.replace(/\\sf_/gm, ` f_${this.uuid}_`).replace(/\\(f_/gm, `(f_${this.uuid}_`)\r\n\r\n    const returnValue = s.match(/^.*return.*$/gm)\r\n    let sReplaced = s.replace(/^.*return.*$/gm, '')\r\n\r\n    if (returnValue?.[0]) {\r\n      const returnVariable = returnValue[0].replace('return', '').trim().replace(';', '')\r\n\r\n      const blendMode = this.getBlendMode(returnVariable, 'lamina_finalColor')\r\n      sReplaced += isVertex ? `lamina_finalPosition = ${returnVariable};` : `lamina_finalColor = ${blendMode};`\r\n    }\r\n\r\n    return sReplaced\r\n  }\r\n\r\n  getShaderFromIndex(tokens: any, index: number[]) {\r\n    return stringify(tokens.slice(index[0], index[1]))\r\n  }\r\n\r\n  getBlendMode(b: string, a: string) {\r\n    switch (this.mode) {\r\n      default:\r\n      case 'normal':\r\n        return `lamina_blend_alpha(${a}, ${b}, ${b}.a)`\r\n      case 'add':\r\n        return `lamina_blend_add(${a}, ${b}, ${b}.a)`\r\n      case 'subtract':\r\n        return `lamina_blend_subtract(${a}, ${b}, ${b}.a)`\r\n      case 'multiply':\r\n        return `lamina_blend_multiply(${a}, ${b}, ${b}.a)`\r\n      case 'lighten':\r\n        return `lamina_blend_lighten(${a}, ${b}, ${b}.a)`\r\n      case 'darken':\r\n        return `lamina_blend_darken(${a}, ${b}, ${b}.a)`\r\n      case 'divide':\r\n        return `lamina_blend_divide(${a}, ${b}, ${b}.a)`\r\n      case 'overlay':\r\n        return `lamina_blend_overlay(${a}, ${b}, ${b}.a)`\r\n      case 'screen':\r\n        return `lamina_blend_screen(${a}, ${b}, ${b}.a)`\r\n      case 'softlight':\r\n        return `lamina_blend_softlight(${a}, ${b}, ${b}.a)`\r\n      case 'reflect':\r\n        return `lamina_blend_reflect(${a}, ${b}, ${b}.a)`\r\n      case 'negation':\r\n        return `lamina_blend_negation(${a}, ${b}, ${b}.a)`\r\n    }\r\n  }\r\n\r\n  getSchema() {\r\n    const latestSchema = this.schema.map(({ label, options, ...rest }) => {\r\n      return {\r\n        label,\r\n        options,\r\n        ...getSpecialParameters(label),\r\n        ...rest,\r\n        // @ts-ignore\r\n        value: serializeProp(this[label]),\r\n      }\r\n    })\r\n\r\n    return latestSchema\r\n  }\r\n\r\n  serialize(): SerializedLayer {\r\n    const name = this.constructor.name.split('$')[0]\r\n    let nonUniformPropKeys = Object.keys(this)\r\n    nonUniformPropKeys = nonUniformPropKeys.filter(\r\n      (e) =>\r\n        ![\r\n          'uuid',\r\n          'uniforms',\r\n          'schema',\r\n          'fragmentShader',\r\n          'vertexShader',\r\n          'fragmentVariables',\r\n          'vertexVariables',\r\n          'attribs',\r\n          'events',\r\n          '__r3f',\r\n          'onParse',\r\n        ].includes(e)\r\n    )\r\n    const nonUniformProps = {}\r\n    nonUniformPropKeys.forEach((k) => {\r\n      // @ts-ignore\r\n      nonUniformProps[k] = this[k]\r\n    })\r\n\r\n    const props: { [key: string]: any } = {}\r\n    for (const key in this.uniforms) {\r\n      const name = key.replace(`u_${this.uuid}_`, '')\r\n      props[name] = serializeProp(this.uniforms[key].value)\r\n    }\r\n\r\n    return {\r\n      constructor: name,\r\n      properties: {\r\n        ...props,\r\n        ...nonUniformProps,\r\n      },\r\n    }\r\n  }\r\n}\r\n", "import { ColorProps } from '../types'\r\nimport Abstract from './Abstract'\r\n\r\nexport default class Color extends Abstract {\r\n  static u_color = 'red'\r\n  static u_alpha = 1\r\n\r\n  static fragmentShader = `   \r\n    uniform vec3 u_color;\r\n    uniform float u_alpha;\r\n\r\n    void main() {\r\n      return vec4(u_color, u_alpha);\r\n    }\r\n  `\r\n\r\n  constructor(props?: ColorProps) {\r\n    super(Color, {\r\n      name: 'Color',\r\n      ...props,\r\n    })\r\n  }\r\n}\r\n", "import { Vector3 } from 'three'\r\nimport { DepthProps } from '../types'\r\nimport Abstract from './Abstract'\r\n\r\ntype AbstractExtended = Abstract & {\r\n  mapping: DepthProps['mapping']\r\n}\r\n\r\nexport default class Depth extends Abstract {\r\n  static u_near = 2\r\n  static u_far = 10\r\n  static u_origin = new Vector3(0, 0, 0)\r\n  static u_colorA = 'white'\r\n  static u_colorB = 'black'\r\n  static u_alpha = 1\r\n\r\n  static vertexShader = `\r\n  varying vec3 v_worldPosition;\r\n  varying vec3 v_position;\r\n\r\n  void main() {\r\n    v_worldPosition = (vec4(position, 1.0) * modelMatrix).xyz;\r\n    v_position = position;\r\n  }\r\n  `\r\n\r\n  static fragmentShader = `   \r\n    uniform float u_alpha;\r\n    uniform float u_near;\r\n    uniform float u_far;\r\n    uniform float u_isVector;\r\n    uniform vec3 u_origin;\r\n    uniform vec3 u_colorA;\r\n    uniform vec3 u_colorB;\r\n\r\n    varying vec3 v_worldPosition;\r\n    varying vec3 v_position;\r\n\r\n    void main() {\r\n      float f_dist = lamina_mapping_template;\r\n      float f_depth = (f_dist - u_near) / (u_far - u_near);\r\n\t\t\tvec3 f_depthColor =  mix(u_colorB, u_colorA, 1.0 - clamp(f_depth, 0., 1.));\r\n  \r\n  \r\n      return vec4(f_depthColor, u_alpha);\r\n    }\r\n  `\r\n\r\n  mapping: 'vector' | 'world' | 'camera' = 'vector'\r\n\r\n  constructor(props?: DepthProps) {\r\n    super(\r\n      Depth,\r\n      {\r\n        name: 'Depth',\r\n        ...props,\r\n      },\r\n      (self: Depth) => {\r\n        self.schema.push({\r\n          value: self.mapping,\r\n          label: 'mapping',\r\n          options: ['vector', 'world', 'camera'],\r\n        })\r\n\r\n        const mapping = Depth.getMapping(self.uuid, self.mapping)\r\n\r\n        self.fragmentShader = self.fragmentShader.replace('lamina_mapping_template', mapping)\r\n      }\r\n    )\r\n  }\r\n\r\n  private static getMapping(uuid: string, type?: string) {\r\n    switch (type) {\r\n      default:\r\n      case 'vector':\r\n        return `length(v_${uuid}_worldPosition - u_${uuid}_origin)`\r\n      case 'world':\r\n        return `length(v_${uuid}_position - vec3(0.))`\r\n      case 'camera':\r\n        return `length(v_${uuid}_worldPosition - cameraPosition)`\r\n    }\r\n  }\r\n}\r\n", "import { Vector3 } from 'three'\r\nimport { ColorProps, DisplaceProps, MappingType, MappingTypes, NoiseProps, NoiseType, NoiseTypes } from '../types'\r\nimport Abstract from './Abstract'\r\n\r\ntype AbstractExtended = Abstract & {\r\n  type: NoiseType\r\n  mapping: MappingType\r\n}\r\n\r\nexport default class Displace extends Abstract {\r\n  static u_strength = 1\r\n  static u_scale = 1\r\n  static u_offset = new Vector3(0, 0, 0)\r\n\r\n  static vertexShader = `\r\n       \r\n      uniform float u_strength;\r\n      uniform float u_scale;\r\n      uniform vec3 u_offset;\r\n\r\n      vec3 displace(vec3 p) {\r\n\t\t\t\tvec3 f_position = lamina_mapping_template;\r\n        float f_n = lamina_noise_template((f_position + u_offset) * u_scale) * u_strength;\r\n        vec3 f_newPosition = p + (f_n * normal);\r\n\r\n\t\t\t\treturn f_newPosition;\r\n      }\r\n\r\n      \r\n\t\t\tvec3 orthogonal(vec3 v) {\r\n  \t\t  return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)\r\n  \t\t  : vec3(0.0, -v.z, v.y));\r\n  \t\t}\r\n  \t\tvec3 recalcNormals(vec3 newPos) {\r\n  \t\t  float offset = 0.001;\r\n  \t\t  vec3 tangent = orthogonal(normal);\r\n  \t\t  vec3 bitangent = normalize(cross(normal, tangent));\r\n  \t\t  vec3 neighbour1 = position + tangent * offset;\r\n  \t\t  vec3 neighbour2 = position + bitangent * offset;\r\n  \t\t  vec3 displacedNeighbour1 = displace(neighbour1);\r\n  \t\t  vec3 displacedNeighbour2 = displace(neighbour2);\r\n  \t\t  vec3 displacedTangent = displacedNeighbour1 - newPos;\r\n  \t\t  vec3 displacedBitangent = displacedNeighbour2 - newPos;\r\n  \t\t  return normalize(cross(displacedTangent, displacedBitangent));\r\n  \t\t}\r\n  \r\n  \r\n      void main() {\r\n       \r\n\t\t\t\tvec3 f_newPosition = displace(position);\r\n        lamina_finalNormal = recalcNormals(f_newPosition);\r\n\r\n        return f_newPosition;\r\n      }\r\n    `\r\n\r\n  type: NoiseType = 'perlin'\r\n  mapping: MappingType = 'local'\r\n\r\n  constructor(props?: DisplaceProps) {\r\n    super(\r\n      Displace,\r\n      {\r\n        name: 'Displace',\r\n        ...props,\r\n      },\r\n      (self: Displace) => {\r\n        self.schema.push({\r\n          value: self.type,\r\n          label: 'type',\r\n          options: Object.values(NoiseTypes),\r\n        })\r\n\r\n        self.schema.push({\r\n          value: self.mapping,\r\n          label: 'mapping',\r\n          options: Object.values(MappingTypes),\r\n        })\r\n\r\n        const noiseFunc = Displace.getNoiseFunction(self.type)\r\n        const mapping = Displace.getMapping(self.mapping)\r\n\r\n        self.vertexVariables = self.vertexVariables.replace('lamina_mapping_template', mapping)\r\n        self.vertexVariables = self.vertexVariables.replace('lamina_noise_template', noiseFunc)\r\n      }\r\n    )\r\n  }\r\n\r\n  private static getNoiseFunction(type?: string) {\r\n    switch (type) {\r\n      default:\r\n      case 'perlin':\r\n        return `lamina_noise_perlin`\r\n      case 'simplex':\r\n        return `lamina_noise_simplex`\r\n      case 'cell':\r\n        return `lamina_noise_worley`\r\n      case 'white':\r\n        return `lamina_noise_white`\r\n      case 'curl':\r\n        return `lamina_noise_swirl`\r\n    }\r\n  }\r\n\r\n  private static getMapping(type?: string) {\r\n    switch (type) {\r\n      default:\r\n      case 'local':\r\n        return `p`\r\n      case 'world':\r\n        return `(modelMatrix * vec4(p,1.0)).xyz`\r\n      case 'uv':\r\n        return `vec3(uv, 0.)`\r\n    }\r\n  }\r\n}\r\n", "import { FresnelProps } from '../types'\r\nimport Abstract from './Abstract'\r\n\r\nexport default class Fresnel extends Abstract {\r\n  static u_color = 'white'\r\n  static u_alpha = 1\r\n  static u_bias = 0\r\n  static u_intensity = 1\r\n  static u_power = 2\r\n  static u_factor = 1\r\n\r\n  static vertexShader = `\r\n    varying vec3 v_worldPosition;\r\n    varying vec3 v_worldNormal;\r\n\r\n    void main() {\r\n        v_worldPosition = vec3(-viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2]);\r\n        v_worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\r\n        \r\n    }\r\n  `\r\n\r\n  static fragmentShader = `   \r\n    uniform vec3 u_color;\r\n    uniform float u_alpha;\r\n    uniform float u_bias;\r\n    uniform float u_intensity;\r\n    uniform float u_power;\r\n    uniform float u_factor;\r\n\r\n    varying vec3 v_worldPosition;\r\n    varying vec3 v_worldNormal;\r\n\r\n    void main() {\r\n        float f_a = (u_factor  + dot(v_worldPosition, v_worldNormal));\r\n        float f_fresnel = u_bias + u_intensity * pow(abs(f_a), u_power);\r\n\r\n        f_fresnel = clamp(f_fresnel, 0.0, 1.0);\r\n        return vec4(f_fresnel * u_color, u_alpha);\r\n    }\r\n  `\r\n\r\n  constructor(props?: FresnelProps) {\r\n    super(Fresnel, {\r\n      name: 'Fresnel',\r\n      ...props,\r\n    })\r\n  }\r\n}\r\n", "import { Vector3 } from 'three'\r\nimport { GradientProps, MappingType, MappingTypes } from '../types'\r\nimport Abstract from './Abstract'\r\n\r\nexport default class Gradient extends Abstract {\r\n  static u_colorA = 'white'\r\n  static u_colorB = 'black'\r\n  static u_alpha = 1\r\n\r\n  static u_start = 1\r\n  static u_end = -1\r\n  static u_contrast = 1\r\n\r\n  static vertexShader = `\r\n\t\tvarying vec3 v_position;\r\n\r\n\t\tvod main() {\r\n      v_position = lamina_mapping_template;\r\n\t\t}\r\n  `\r\n\r\n  static fragmentShader = `   \r\n    uniform vec3 u_colorA;\r\n    uniform vec3 u_colorB;\r\n    uniform vec3 u_axis;\r\n    uniform float u_alpha;\r\n    uniform float u_start;\r\n    uniform float u_end;\r\n    uniform float u_contrast;\r\n\r\n\t\tvarying vec3 v_position;\r\n\r\n    void main() {\r\n\r\n      float f_step = smoothstep(u_start, u_end, v_position.axes_template * u_contrast);\r\n      vec3 f_color = mix(u_colorA, u_colorB, f_step);\r\n\r\n      return vec4(f_color, u_alpha);\r\n    }\r\n  `\r\n\r\n  axes: 'x' | 'y' | 'z' = 'x'\r\n  mapping: MappingType = 'local'\r\n\r\n  constructor(props?: GradientProps) {\r\n    super(\r\n      Gradient,\r\n      {\r\n        name: 'Gradient',\r\n        ...props,\r\n      },\r\n      (self: Gradient) => {\r\n        self.schema.push({\r\n          value: self.axes,\r\n          label: 'axes',\r\n          options: ['x', 'y', 'z'],\r\n        })\r\n\r\n        self.schema.push({\r\n          value: self.mapping,\r\n          label: 'mapping',\r\n          options: Object.values(MappingTypes),\r\n        })\r\n\r\n        const mapping = Gradient.getMapping(self.mapping)\r\n\r\n        self.vertexShader = self.vertexShader.replace('lamina_mapping_template', mapping || 'local')\r\n        self.fragmentShader = self.fragmentShader.replace('axes_template', self.axes || 'x')\r\n      }\r\n    )\r\n  }\r\n\r\n  private static getMapping(type?: string) {\r\n    switch (type) {\r\n      default:\r\n      case 'local':\r\n        return `position`\r\n      case 'world':\r\n        return `(modelMatrix * vec4(position,1.0)).xyz`\r\n      case 'uv':\r\n        return `vec3(uv, 0.)`\r\n    }\r\n  }\r\n}\r\n", "import { MatcapProps } from \"../types\";\r\nimport Abstract from \"./Abstract\";\r\n\r\n// Credits: https://www.clicktorelease.com/blog/creating-spherical-environment-mapping-shader/\r\n\r\nexport default class Matcap extends Abstract {\r\n  static u_alpha = 1;\r\n  static u_map = undefined;\r\n\r\n  static vertexShader = `\r\n    varying vec3 v_position;\r\n    varying vec3 v_normal;\r\n    \r\n    void main() {\r\n      v_position = normalize( vec3( modelViewMatrix * vec4( position, 1.0 ) ) );\r\n      v_normal = normalize( normalMatrix * normal );\r\n    }\r\n    `;\r\n\r\n  static fragmentShader = ` \r\n\t\tuniform sampler2D u_map;  \r\n\t\tuniform float u_alpha;  \r\n\t\tvarying vec3 v_position;\r\n\t\tvarying vec3 v_normal;\r\n\r\n\t\t\r\n    void main() {\r\n\t\t\tvec3 f_r = reflect( v_position, v_normal );\r\n\t\t\tfloat f_m = 2. * sqrt( pow( f_r.x, 2. ) + pow( f_r.y, 2. ) + pow( f_r.z + 1., 2. ) );\r\n\t\t\tvec2 f_vN = f_r.xy / f_m + .5;\r\n\r\n\t\t\tvec3 f_base = texture2D(u_map, f_vN).rgb;\r\n\r\n      return vec4(f_base, u_alpha);\r\n    }\r\n  `;\r\n\r\n  constructor(props?: MatcapProps) {\r\n    super(Matcap, {\r\n      name: \"Matcap\",\r\n      ...props,\r\n    });\r\n  }\r\n}\r\n", "import { Vector3 } from 'three'\r\nimport { ColorProps, MappingType, MappingTypes, NoiseProps, NoiseType, NoiseTypes } from '../types'\r\nimport Abstract from './Abstract'\r\n\r\ntype AbstractExtended = Abstract & {\r\n  type: NoiseType\r\n  mapping: MappingType\r\n}\r\n\r\nexport default class Noise extends Abstract {\r\n  static u_colorA = '#666666'\r\n  static u_colorB = '#666666'\r\n  static u_colorC = '#FFFFFF'\r\n  static u_colorD = '#FFFFFF'\r\n\r\n  static u_alpha = 1\r\n  static u_scale = 1\r\n  static u_offset = new Vector3(0, 0, 0)\r\n\r\n  static vertexShader = `\r\n    varying vec3 v_position;\r\n\r\n    void main() {\r\n        v_position = lamina_mapping_template;\r\n    }\r\n  `\r\n\r\n  static fragmentShader = `   \r\n    uniform vec3 u_colorA;\r\n    uniform vec3 u_colorB;\r\n    uniform vec3 u_colorC;\r\n    uniform vec3 u_colorD;\r\n    uniform vec3 u_offset;\r\n\r\n    uniform float u_alpha;\r\n    uniform float u_scale;\r\n\r\n    varying vec3 v_position;\r\n\r\n\r\n    void main() {\r\n        float f_n = lamina_noise_template((v_position + u_offset) * u_scale);\r\n\r\n        float f_step1 = 0.;\r\n        float f_step2 = 0.2;\r\n        float f_step3 = 0.6;\r\n        float f_step4 = 1.;\r\n\r\n        vec3 f_color = mix(u_colorA, u_colorB, smoothstep(f_step1, f_step2, f_n));\r\n        f_color = mix(f_color, u_colorC, smoothstep(f_step2, f_step3, f_n));\r\n        f_color = mix(f_color, u_colorD, smoothstep(f_step3, f_step4, f_n));\r\n\r\n        return vec4(f_color, u_alpha);\r\n    }\r\n  `\r\n\r\n  type: NoiseType = 'perlin'\r\n  mapping: MappingType = 'local'\r\n\r\n  constructor(props?: NoiseProps) {\r\n    super(\r\n      Noise,\r\n      {\r\n        name: 'noise',\r\n        ...props,\r\n      },\r\n      (self: Noise) => {\r\n        self.schema.push({\r\n          value: self.type,\r\n          label: 'type',\r\n          options: Object.values(NoiseTypes),\r\n        })\r\n\r\n        self.schema.push({\r\n          value: self.mapping,\r\n          label: 'mapping',\r\n          options: Object.values(MappingTypes),\r\n        })\r\n\r\n        const noiseFunc = Noise.getNoiseFunction(self.type)\r\n        const mapping = Noise.getMapping(self.mapping)\r\n\r\n        self.vertexShader = self.vertexShader.replace('lamina_mapping_template', mapping)\r\n        self.fragmentShader = self.fragmentShader.replace('lamina_noise_template', noiseFunc)\r\n      }\r\n    )\r\n  }\r\n\r\n  private static getNoiseFunction(type?: string) {\r\n    switch (type) {\r\n      default:\r\n      case 'perlin':\r\n        return `lamina_noise_perlin`\r\n      case 'simplex':\r\n        return `lamina_noise_simplex`\r\n      case 'cell':\r\n        return `lamina_noise_worley`\r\n      case 'white':\r\n        return `lamina_noise_white`\r\n      case 'curl':\r\n        return `lamina_noise_swirl`\r\n    }\r\n  }\r\n\r\n  private static getMapping(type?: string) {\r\n    switch (type) {\r\n      default:\r\n      case 'local':\r\n        return `position`\r\n      case 'world':\r\n        return `(modelMatrix * vec4(position,1.0)).xyz`\r\n      case 'uv':\r\n        return `vec3(uv, 0.)`\r\n    }\r\n  }\r\n}\r\n", "import { Vector3 } from 'three'\r\nimport { NormalProps } from '../types'\r\nimport Abstract from './Abstract'\r\n\r\nexport default class Normal extends Abstract {\r\n  static u_alpha = 1\r\n  static u_direction = new Vector3(1, 1, 1)\r\n\r\n  static vertexShader = `   \r\n  varying vec3 v_normals; \r\n\r\n  void main() {\r\n    v_normals = normal;\r\n  }\r\n`\r\n\r\n  static fragmentShader = `   \r\n  \tuniform float u_alpha;\r\n  \tuniform vec3 u_color;\r\n  \tuniform vec3 u_direction;\r\n\r\n\t\tvarying vec3 v_normals;\r\n\r\n    void main() {\r\n\t\t\tvec3 f_normalColor = vec3(1.);\r\n      f_normalColor.x = v_normals.x * u_direction.x;\r\n      f_normalColor.y = v_normals.y * u_direction.y;\r\n      f_normalColor.z = v_normals.z * u_direction.z;\r\n\r\n      return vec4(f_normalColor, u_alpha);\r\n    }\r\n  `\r\n\r\n  constructor(props?: NormalProps) {\r\n    super(Normal, {\r\n      name: 'Normal',\r\n      ...props,\r\n    })\r\n  }\r\n}\r\n", "import { TextureProps } from '../types'\r\nimport Abstract from './Abstract'\r\n\r\nexport default class Texture extends Abstract {\r\n  static u_alpha = 1\r\n  static u_map = undefined\r\n\r\n  static vertexShader = `\r\n    varying vec2 v_uv;\r\n    \r\n    void main() {\r\n        v_uv = uv;\r\n    }\r\n    `\r\n\r\n  static fragmentShader = ` \r\n\t\tuniform sampler2D u_map;  \r\n\t\tuniform float u_alpha;  \r\n\t\tvarying vec2 v_uv;\r\n\r\n    void main() {\r\n\t\t\tvec4 f_color = texture2D(u_map, v_uv);\r\n      return vec4(f_color.rgb, f_color.a * u_alpha);\r\n    }\r\n  `\r\n\r\n  constructor(props?: TextureProps) {\r\n    super(Texture, {\r\n      name: 'Texture',\r\n      ...props,\r\n    })\r\n  }\r\n}\r\n", "export default /* glsl */ `\r\nvec4 lamina_blend_add(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\treturn vec4(min(x.xyz + y.xyz, 1.0) * opacity + x.xyz * (1.0 - opacity), x.a);\r\n\r\n}\r\nvec3 lamina_blend_alpha(const in vec3 x, const in vec3 y, const in float opacity) {\r\n\r\n\treturn y * opacity + x * (1.0 - opacity);\r\n\r\n}\r\n\r\nvec4 lamina_blend_alpha(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\tfloat a = min(y.a, opacity);\r\n\r\n\treturn vec4(lamina_blend_alpha(x.rgb, y.rgb, a), x.a);\r\n\r\n}\r\nvec4 lamina_blend_average(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\treturn vec4((x.xyz + y.xyz) * 0.5 * opacity + x.xyz * (1.0 - opacity), x.a);\r\n\r\n}\r\nfloat lamina_blend_color_burn(const in float x, const in float y) {\r\n\r\n\treturn (y == 0.0) ? y : max(1.0 - (1.0 - x) / y, 0.0);\r\n\r\n}\r\n\r\nvec4 lamina_blend_color_burn(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\tvec4 z = vec4(\r\n\t\tlamina_blend_color_burn(x.r, y.r),\r\n\t\tlamina_blend_color_burn(x.g, y.g),\r\n\t\tlamina_blend_color_burn(x.b, y.b),\r\n\t\tlamina_blend_color_burn(x.a, y.a)\r\n\t);\r\n\r\n\treturn vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\r\n\r\n}\r\nfloat lamina_blend_color_dodge(const in float x, const in float y) {\r\n\r\n\treturn (y == 1.0) ? y : min(x / (1.0 - y), 1.0);\r\n\r\n}\r\n\r\nvec4 lamina_blend_color_dodge(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\tvec4 z = vec4(\r\n\t\tlamina_blend_color_dodge(x.r, y.r),\r\n\t\tlamina_blend_color_dodge(x.g, y.g),\r\n\t\tlamina_blend_color_dodge(x.b, y.b),\r\n\t\tlamina_blend_color_dodge(x.a, y.a)\r\n\t);\r\n\r\n\treturn vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\r\n\r\n}\r\nvec4 lamina_blend_darken(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\treturn vec4(min(x.xyz, y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);\r\n\r\n}\r\nvec4 lamina_blend_difference(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\treturn vec4(abs(x.xyz - y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);\r\n\r\n}\r\nfloat lamina_blend_divide(const in float x, const in float y) {\r\n\r\n\treturn (y > 0.0) ? min(x / y, 1.0) : 1.0;\r\n\r\n}\r\n\r\nvec4 lamina_blend_divide(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\tvec4 z = vec4(\r\n\t\tlamina_blend_divide(x.r, y.r),\r\n\t\tlamina_blend_divide(x.g, y.g),\r\n\t\tlamina_blend_divide(x.b, y.b),\r\n\t\tlamina_blend_divide(x.a, y.a)\r\n\t);\r\n\r\n\treturn vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\r\n\r\n}\r\nvec4 lamina_blend_exclusion(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\treturn vec4((x.xyz + y.xyz - 2.0 * x.xyz * y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);\r\n\r\n}\r\nvec4 lamina_blend_lighten(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\treturn vec4(max(x.xyz, y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);\r\n\r\n}\r\nvec4 lamina_blend_multiply(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\treturn vec4( x.xyz * y.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\r\n\r\n}\r\nvec4 lamina_blend_negation(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\treturn vec4((1.0 - abs(1.0 - x.xyz - y.xyz)) * opacity + x.xyz * (1.0 - opacity), x.a);\r\n\r\n}\r\nvec4 lamina_blend_normal(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\treturn vec4(y.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\r\n\r\n}\r\nfloat lamina_blend_overlay(const in float x, const in float y) {\r\n\r\n\treturn (x < 0.5) ? (2.0 * x * y) : (1.0 - 2.0 * (1.0 - x) * (1.0 - y));\r\n\r\n}\r\n\r\nvec4 lamina_blend_overlay(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\tvec4 z = vec4(\r\n\t\tlamina_blend_overlay(x.r, y.r),\r\n\t\tlamina_blend_overlay(x.g, y.g),\r\n\t\tlamina_blend_overlay(x.b, y.b),\r\n\t\tlamina_blend_overlay(x.a, y.a)\r\n\t);\r\n\r\n\treturn vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\r\n\r\n}\r\nfloat lamina_blend_reflect(const in float x, const in float y) {\r\n\r\n\treturn (y == 1.0) ? y : min(x * x / (1.0 - y), 1.0);\r\n\r\n}\r\n\r\nvec4 lamina_blend_reflect(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\tvec4 z = vec4(\r\n\t\tlamina_blend_reflect(x.r, y.r),\r\n\t\tlamina_blend_reflect(x.g, y.g),\r\n\t\tlamina_blend_reflect(x.b, y.b),\r\n\t\tlamina_blend_reflect(x.a, y.a)\r\n\t);\r\n\r\n\treturn vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\r\n\r\n}\r\nvec4 lamina_blend_screen(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\treturn vec4((1.0 - (1.0 - x.xyz) * (1.0 - y.xyz)) * opacity + x.xyz * (1.0 - opacity), x.a);\r\n\r\n}\r\nfloat lamina_blend_softlight(const in float x, const in float y) {\r\n\r\n\treturn (y < 0.5) ?\r\n\t\t(2.0 * x * y + x * x * (1.0 - 2.0 * y)) :\r\n\t\t(sqrt(x) * (2.0 * y - 1.0) + 2.0 * x * (1.0 - y));\r\n\r\n}\r\n\r\nvec4 lamina_blend_softlight(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\tvec4 z = vec4(\r\n\t\tlamina_blend_softlight(x.r, y.r),\r\n\t\tlamina_blend_softlight(x.g, y.g),\r\n\t\tlamina_blend_softlight(x.b, y.b),\r\n\t\tlamina_blend_softlight(x.a, y.a)\r\n\t);\r\n\r\n\treturn vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);\r\n\r\n}\r\nvec4 lamina_blend_subtract(const in vec4 x, const in vec4 y, const in float opacity) {\r\n\r\n\treturn vec4(max(x.xyz + y.xyz - 1.0, 0.0) * opacity + x.xyz * (1.0 - opacity), x.a);\r\n\r\n}\r\n\r\n`\r\n", "export default /* glsl */ `\r\n\r\nfloat lamina_map(float value, float min1, float max1, float min2, float max2) {\r\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\r\n}\r\n\r\nfloat lamina_normalize(float v) { return lamina_map(v, -1.0, 1.0, 0.0, 1.0); }\r\n`;\r\n", "export default /* glsl */ `\r\n\r\n// From: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\r\n// Huge thanks to the creators of these algorithms\r\n\r\nfloat lamina_noise_mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\r\nvec4 lamina_noise_mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\r\nvec4 lamina_noise_perm(vec4 x){return lamina_noise_mod289(((x * 34.0) + 1.0) * x);}\r\nvec4 lamina_noise_permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\r\nvec4 lamina_noise_taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\r\n\r\n\r\nfloat lamina_noise_white(vec2 p) {\r\n  return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) *\r\n               (0.1 + abs(sin(p.y * 13.0 + p.x))));\r\n}\r\n\r\nfloat lamina_noise_white(vec3 p) {\r\n  return lamina_noise_white(p.xy);\r\n}\r\n\r\n\r\nvec3 lamina_noise_fade(vec3 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }\r\n\r\nfloat lamina_noise_perlin(vec3 P) {\r\n  vec3 Pi0 = floor(P);        // Integer part for indexing\r\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\r\n  Pi0 = mod(Pi0, 289.0);\r\n  Pi1 = mod(Pi1, 289.0);\r\n  vec3 Pf0 = fract(P);        // Fractional part for interpolation\r\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\r\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\r\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\r\n  vec4 iz0 = Pi0.zzzz;\r\n  vec4 iz1 = Pi1.zzzz;\r\n\r\n  vec4 ixy = lamina_noise_permute(lamina_noise_permute(ix) + iy);\r\n  vec4 ixy0 = lamina_noise_permute(ixy + iz0);\r\n  vec4 ixy1 = lamina_noise_permute(ixy + iz1);\r\n\r\n  vec4 gx0 = ixy0 / 7.0;\r\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\r\n  gx0 = fract(gx0);\r\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\r\n  vec4 sz0 = step(gz0, vec4(0.0));\r\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\r\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\r\n\r\n  vec4 gx1 = ixy1 / 7.0;\r\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\r\n  gx1 = fract(gx1);\r\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\r\n  vec4 sz1 = step(gz1, vec4(0.0));\r\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\r\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\r\n\r\n  vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\r\n  vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\r\n  vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\r\n  vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\r\n  vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\r\n  vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\r\n  vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\r\n  vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\r\n\r\n  vec4 norm0 = lamina_noise_taylorInvSqrt(\r\n      vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\r\n  g000 *= norm0.x;\r\n  g010 *= norm0.y;\r\n  g100 *= norm0.z;\r\n  g110 *= norm0.w;\r\n  vec4 norm1 = lamina_noise_taylorInvSqrt(\r\n      vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\r\n  g001 *= norm1.x;\r\n  g011 *= norm1.y;\r\n  g101 *= norm1.z;\r\n  g111 *= norm1.w;\r\n\r\n  float n000 = dot(g000, Pf0);\r\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\r\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\r\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\r\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\r\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\r\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\r\n  float n111 = dot(g111, Pf1);\r\n\r\n  vec3 fade_xyz = lamina_noise_fade(Pf0);\r\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111),\r\n                 fade_xyz.z);\r\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\r\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\r\n  return lamina_normalize(2.2 * n_xyz);\r\n}\r\n\r\nfloat lamina_noise_simplex(vec3 v) {\r\n  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\r\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\r\n\r\n  // First corner\r\n  vec3 i = floor(v + dot(v, C.yyy));\r\n  vec3 x0 = v - i + dot(i, C.xxx);\r\n\r\n  // Other corners\r\n  vec3 g = step(x0.yzx, x0.xyz);\r\n  vec3 l = 1.0 - g;\r\n  vec3 i1 = min(g.xyz, l.zxy);\r\n  vec3 i2 = max(g.xyz, l.zxy);\r\n\r\n  //  x0 = x0 - 0. + 0.0 * C\r\n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\r\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\r\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\r\n\r\n  // Permutations\r\n  i = mod(i, 289.0);\r\n  vec4 p = lamina_noise_permute(lamina_noise_permute(lamina_noise_permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y +\r\n                             vec4(0.0, i1.y, i2.y, 1.0)) +\r\n                    i.x + vec4(0.0, i1.x, i2.x, 1.0));\r\n\r\n  // Gradients\r\n  // ( N*N points uniformly over a square, mapped onto an octahedron.)\r\n  float n_ = 1.0 / 7.0; // N=7\r\n  vec3 ns = n_ * D.wyz - D.xzx;\r\n\r\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); //  mod(p,N*N)\r\n\r\n  vec4 x_ = floor(j * ns.z);\r\n  vec4 y_ = floor(j - 7.0 * x_); // mod(j,N)\r\n\r\n  vec4 x = x_ * ns.x + ns.yyyy;\r\n  vec4 y = y_ * ns.x + ns.yyyy;\r\n  vec4 h = 1.0 - abs(x) - abs(y);\r\n\r\n  vec4 b0 = vec4(x.xy, y.xy);\r\n  vec4 b1 = vec4(x.zw, y.zw);\r\n\r\n  vec4 s0 = floor(b0) * 2.0 + 1.0;\r\n  vec4 s1 = floor(b1) * 2.0 + 1.0;\r\n  vec4 sh = -step(h, vec4(0.0));\r\n\r\n  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\r\n  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\r\n\r\n  vec3 p0 = vec3(a0.xy, h.x);\r\n  vec3 p1 = vec3(a0.zw, h.y);\r\n  vec3 p2 = vec3(a1.xy, h.z);\r\n  vec3 p3 = vec3(a1.zw, h.w);\r\n\r\n  // Normalise gradients\r\n  vec4 norm =\r\n      lamina_noise_taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\r\n  p0 *= norm.x;\r\n  p1 *= norm.y;\r\n  p2 *= norm.z;\r\n  p3 *= norm.w;\r\n\r\n  // Mix final noise value\r\n  vec4 m =\r\n      max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\r\n  m = m * m;\r\n  return lamina_normalize(42.0 *\r\n         dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3))));\r\n}\r\n\r\nvec3 lamina_noise_simplex3(vec3 x) {\r\n  float s = lamina_noise_simplex(vec3(x));\r\n  float s1 = lamina_noise_simplex(vec3(x.y - 19.1, x.z + 33.4, x.x + 47.2));\r\n  float s2 = lamina_noise_simplex(vec3(x.z + 74.2, x.x - 124.5, x.y + 99.4));\r\n  vec3 c = vec3(s, s1, s2);\r\n  return c;\r\n}\r\n\r\nvec3 lamina_noise_curl(vec3 p) {\r\n  const float e = .1;\r\n  vec3 dx = vec3(e, 0.0, 0.0);\r\n  vec3 dy = vec3(0.0, e, 0.0);\r\n  vec3 dz = vec3(0.0, 0.0, e);\r\n\r\n  vec3 p_x0 = lamina_noise_simplex3(p - dx);\r\n  vec3 p_x1 = lamina_noise_simplex3(p + dx);\r\n  vec3 p_y0 = lamina_noise_simplex3(p - dy);\r\n  vec3 p_y1 = lamina_noise_simplex3(p + dy);\r\n  vec3 p_z0 = lamina_noise_simplex3(p - dz);\r\n  vec3 p_z1 = lamina_noise_simplex3(p + dz);\r\n\r\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\r\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\r\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\r\n\r\n  const float divisor = 1.0 / (2.0 * e);\r\n  return normalize(vec3(x, y, z) * divisor);\r\n}\r\n\r\nvec3 lamina_permute(vec3 x) {\r\n  return mod((34.0 * x + 1.0) * x, 289.0);\r\n}\r\n\r\nvec3 lamina_dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance) {\r\n  return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);\r\n}\r\n\r\n// From: https://github.com/Erkaman/glsl-worley\r\nfloat lamina_noise_worley(vec3 P) {\r\n  float jitter = 1.;\r\n  bool manhattanDistance = false; \r\n\r\n  float K = 0.142857142857; // 1/7\r\n  float Ko = 0.428571428571; // 1/2-K/2\r\n  float  K2 = 0.020408163265306; // 1/(7*7)\r\n  float Kz = 0.166666666667; // 1/6\r\n  float Kzo = 0.416666666667; // 1/2-1/6*2\r\n\r\n\tvec3 Pi = mod(floor(P), 289.0);\r\n \tvec3 Pf = fract(P) - 0.5;\r\n\r\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\r\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\r\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\r\n\r\n\tvec3 p = lamina_permute(Pi.x + vec3(-1.0, 0.0, 1.0));\r\n\tvec3 p1 = lamina_permute(p + Pi.y - 1.0);\r\n\tvec3 p2 = lamina_permute(p + Pi.y);\r\n\tvec3 p3 = lamina_permute(p + Pi.y + 1.0);\r\n\r\n\tvec3 p11 = lamina_permute(p1 + Pi.z - 1.0);\r\n\tvec3 p12 = lamina_permute(p1 + Pi.z);\r\n\tvec3 p13 = lamina_permute(p1 + Pi.z + 1.0);\r\n\r\n\tvec3 p21 = lamina_permute(p2 + Pi.z - 1.0);\r\n\tvec3 p22 = lamina_permute(p2 + Pi.z);\r\n\tvec3 p23 = lamina_permute(p2 + Pi.z + 1.0);\r\n\r\n\tvec3 p31 = lamina_permute(p3 + Pi.z - 1.0);\r\n\tvec3 p32 = lamina_permute(p3 + Pi.z);\r\n\tvec3 p33 = lamina_permute(p3 + Pi.z + 1.0);\r\n\r\n\tvec3 ox11 = fract(p11*K) - Ko;\r\n\tvec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\r\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\r\n\r\n\tvec3 ox12 = fract(p12*K) - Ko;\r\n\tvec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\r\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\r\n\r\n\tvec3 ox13 = fract(p13*K) - Ko;\r\n\tvec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\r\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\r\n\r\n\tvec3 ox21 = fract(p21*K) - Ko;\r\n\tvec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\r\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\r\n\r\n\tvec3 ox22 = fract(p22*K) - Ko;\r\n\tvec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\r\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\r\n\r\n\tvec3 ox23 = fract(p23*K) - Ko;\r\n\tvec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\r\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\r\n\r\n\tvec3 ox31 = fract(p31*K) - Ko;\r\n\tvec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\r\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\r\n\r\n\tvec3 ox32 = fract(p32*K) - Ko;\r\n\tvec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\r\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\r\n\r\n\tvec3 ox33 = fract(p33*K) - Ko;\r\n\tvec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\r\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\r\n\r\n\tvec3 dx11 = Pfx + jitter*ox11;\r\n\tvec3 dy11 = Pfy.x + jitter*oy11;\r\n\tvec3 dz11 = Pfz.x + jitter*oz11;\r\n\r\n\tvec3 dx12 = Pfx + jitter*ox12;\r\n\tvec3 dy12 = Pfy.x + jitter*oy12;\r\n\tvec3 dz12 = Pfz.y + jitter*oz12;\r\n\r\n\tvec3 dx13 = Pfx + jitter*ox13;\r\n\tvec3 dy13 = Pfy.x + jitter*oy13;\r\n\tvec3 dz13 = Pfz.z + jitter*oz13;\r\n\r\n\tvec3 dx21 = Pfx + jitter*ox21;\r\n\tvec3 dy21 = Pfy.y + jitter*oy21;\r\n\tvec3 dz21 = Pfz.x + jitter*oz21;\r\n\r\n\tvec3 dx22 = Pfx + jitter*ox22;\r\n\tvec3 dy22 = Pfy.y + jitter*oy22;\r\n\tvec3 dz22 = Pfz.y + jitter*oz22;\r\n\r\n\tvec3 dx23 = Pfx + jitter*ox23;\r\n\tvec3 dy23 = Pfy.y + jitter*oy23;\r\n\tvec3 dz23 = Pfz.z + jitter*oz23;\r\n\r\n\tvec3 dx31 = Pfx + jitter*ox31;\r\n\tvec3 dy31 = Pfy.z + jitter*oy31;\r\n\tvec3 dz31 = Pfz.x + jitter*oz31;\r\n\r\n\tvec3 dx32 = Pfx + jitter*ox32;\r\n\tvec3 dy32 = Pfy.z + jitter*oy32;\r\n\tvec3 dz32 = Pfz.y + jitter*oz32;\r\n\r\n\tvec3 dx33 = Pfx + jitter*ox33;\r\n\tvec3 dy33 = Pfy.z + jitter*oy33;\r\n\tvec3 dz33 = Pfz.z + jitter*oz33;\r\n\r\n\tvec3 d11 = lamina_dist(dx11, dy11, dz11, manhattanDistance);\r\n\tvec3 d12 = lamina_dist(dx12, dy12, dz12, manhattanDistance);\r\n\tvec3 d13 = lamina_dist(dx13, dy13, dz13, manhattanDistance);\r\n\tvec3 d21 = lamina_dist(dx21, dy21, dz21, manhattanDistance);\r\n\tvec3 d22 = lamina_dist(dx22, dy22, dz22, manhattanDistance);\r\n\tvec3 d23 = lamina_dist(dx23, dy23, dz23, manhattanDistance);\r\n\tvec3 d31 = lamina_dist(dx31, dy31, dz31, manhattanDistance);\r\n\tvec3 d32 = lamina_dist(dx32, dy32, dz32, manhattanDistance);\r\n\tvec3 d33 = lamina_dist(dx33, dy33, dz33, manhattanDistance);\r\n\r\n\tvec3 d1a = min(d11, d12);\r\n\td12 = max(d11, d12);\r\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\r\n\td13 = max(d1a, d13);\r\n\td12 = min(d12, d13); // 2nd smallest now not in d13\r\n\tvec3 d2a = min(d21, d22);\r\n\td22 = max(d21, d22);\r\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\r\n\td23 = max(d2a, d23);\r\n\td22 = min(d22, d23); // 2nd smallest now not in d23\r\n\tvec3 d3a = min(d31, d32);\r\n\td32 = max(d31, d32);\r\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\r\n\td33 = max(d3a, d33);\r\n\td32 = min(d32, d33); // 2nd smallest now not in d33\r\n\tvec3 da = min(d11, d21);\r\n\td21 = max(d11, d21);\r\n\td11 = min(da, d31); // Smallest now in d11\r\n\td31 = max(da, d31); // 2nd smallest now not in d31\r\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\r\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\r\n\td12 = min(d12, d21); // 2nd smallest now not in d21\r\n\td12 = min(d12, d22); // nor in d22\r\n\td12 = min(d12, d31); // nor in d31\r\n\td12 = min(d12, d32); // nor in d32\r\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\r\n\td11.y = min(d11.y,d12.z); // Only two more to go\r\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\r\n\r\n  vec2 F = sqrt(d11.xy);\r\n\treturn F.x; // F1, F2\r\n\r\n}\r\n\r\nfloat lamina_noise_swirl(vec3 position) {\r\n    float scale = 0.1;\r\n    float freq = 4. * scale;\r\n    float t = 1.;\r\n\r\n    vec3 pos = (position * scale) + lamina_noise_curl(position * 7. * scale);\r\n\r\n    float worley1 = 1. - lamina_noise_worley((pos * (freq * 2.)) +  (t * 2.));\r\n    float worley2 = 1. - lamina_noise_worley((pos * (freq * 4.)) +  (t * 4.));\r\n    float worley3 = 1. - lamina_noise_worley((pos * (freq * 8.)) +  (t * 8.));\r\n    float worley4 = 1. - lamina_noise_worley((pos * (freq * 16.)) +  (t * 16.));\r\n    \r\n    float fbm1 = worley1 * .625 + worley2 * .25 + worley3 * .125;\r\n    float fbm2 = worley2 * .625 + worley3 * .25 + worley4 * .125;\r\n    float fbm3 = worley3 * .75 + worley4 * .25;\r\n\r\n    vec3 curlWorleyFbm = vec3(fbm1, fbm2, fbm3);\r\n    float curlWorley = curlWorleyFbm.r * .625 + curlWorleyFbm.g * .25 + \r\n        curlWorleyFbm.b * .125;\r\n\r\n    return curlWorley;\r\n}\r\n  \r\n  \r\n`;\r\n", "import * as THREE from 'three'\r\n\r\nimport Abstract from './core/Abstract'\r\nimport Color from './core/Color'\r\nimport Depth from './core/Depth'\r\nimport Displace from './core/Displace'\r\nimport Fresnel from './core/Fresnel'\r\nimport Gradient from './core/Gradient'\r\nimport Matcap from './core/Matcap'\r\nimport Noise from './core/Noise'\r\nimport Normal from './core/Normal'\r\nimport Texture from './core/Texture'\r\n\r\nimport {\r\n  ColorRepresentation,\r\n  MeshBasicMaterialParameters,\r\n  MeshLambertMaterialParameters,\r\n  MeshPhongMaterialParameters,\r\n  MeshPhysicalMaterialParameters,\r\n  MeshStandardMaterialParameters,\r\n  MeshToonMaterialParameters,\r\n} from 'three'\r\nimport CustomShaderMaterial from 'three-custom-shader-material/vanilla'\r\nimport BlendModesChunk from './chunks/BlendModes'\r\nimport HelpersChunk from './chunks/Helpers'\r\nimport NoiseChunk from './chunks/Noise'\r\nimport { LayerMaterialParameters, SerializedLayer, ShadingType, ShadingTypes } from './types'\r\n\r\ntype AllMaterialParams =\r\n  | MeshPhongMaterialParameters\r\n  | MeshPhysicalMaterialParameters\r\n  | MeshToonMaterialParameters\r\n  | MeshBasicMaterialParameters\r\n  | MeshLambertMaterialParameters\r\n  | MeshStandardMaterialParameters\r\n\r\nclass LayerMaterial extends CustomShaderMaterial {\r\n  name: string = 'LayerMaterial'\r\n  layers: Abstract[] = []\r\n  lighting: ShadingType = 'basic'\r\n\r\n  constructor({ color, alpha, lighting, layers, name, ...props }: LayerMaterialParameters & AllMaterialParams = {}) {\r\n    super({\r\n      baseMaterial: ShadingTypes[lighting || 'basic'],\r\n      ...props,\r\n    })\r\n\r\n    const _baseColor = color || 'white'\r\n    const _alpha = alpha ?? 1\r\n\r\n    this.uniforms = {\r\n      u_lamina_color: {\r\n        value: typeof _baseColor === 'string' ? new THREE.Color(_baseColor).convertSRGBToLinear() : _baseColor,\r\n      },\r\n      u_lamina_alpha: {\r\n        value: _alpha,\r\n      },\r\n    }\r\n\r\n    this.layers = layers || this.layers\r\n    this.lighting = lighting || this.lighting\r\n    this.name = name || this.name\r\n\r\n    this.refresh()\r\n  }\r\n\r\n  genShaders() {\r\n    let vertexVariables = ''\r\n    let fragmentVariables = ''\r\n    let vertexShader = ''\r\n    let fragmentShader = ''\r\n    let uniforms: any = {}\r\n\r\n    this.layers\r\n      .filter((l) => l.visible)\r\n      .forEach((l) => {\r\n        // l.buildShaders(l.constructor)\r\n\r\n        vertexVariables += l.vertexVariables + '\\n'\r\n        fragmentVariables += l.fragmentVariables + '\\n'\r\n        vertexShader += l.vertexShader + '\\n'\r\n        fragmentShader += l.fragmentShader + '\\n'\r\n\r\n        uniforms = {\r\n          ...uniforms,\r\n          ...l.uniforms,\r\n        }\r\n      })\r\n\r\n    uniforms = {\r\n      ...uniforms,\r\n      ...this.uniforms,\r\n    }\r\n\r\n    return {\r\n      uniforms,\r\n      vertexShader: `\r\n        ${HelpersChunk}\r\n        ${NoiseChunk}\r\n        ${vertexVariables}\r\n\r\n        void main() {\r\n          vec3 lamina_finalPosition = position;\r\n          vec3 lamina_finalNormal = normal;\r\n\r\n          ${vertexShader}\r\n\r\n          csm_Position = lamina_finalPosition;\r\n          csm_Normal = lamina_finalNormal;\r\n        }\r\n        `,\r\n      fragmentShader: `\r\n        ${HelpersChunk}\r\n        ${NoiseChunk}\r\n        ${BlendModesChunk}\r\n        ${fragmentVariables}\r\n\r\n        uniform vec3 u_lamina_color;\r\n        uniform float u_lamina_alpha;\r\n\r\n        void main() {\r\n          vec4 lamina_finalColor = vec4(u_lamina_color, u_lamina_alpha);\r\n\r\n          ${fragmentShader}\r\n\r\n          csm_DiffuseColor = lamina_finalColor;\r\n         \r\n        }\r\n        `,\r\n    }\r\n  }\r\n\r\n  refresh() {\r\n    const { uniforms, fragmentShader, vertexShader } = this.genShaders()\r\n    super.update({ fragmentShader, vertexShader, uniforms })\r\n  }\r\n\r\n  serialize(): SerializedLayer {\r\n    return {\r\n      constructor: 'LayerMaterial',\r\n      properties: {\r\n        color: this.color,\r\n        alpha: this.alpha,\r\n        name: this.name,\r\n        lighting: this.lighting,\r\n      },\r\n    }\r\n  }\r\n\r\n  set color(v: ColorRepresentation) {\r\n    if (this.uniforms?.u_lamina_color?.value)\r\n      this.uniforms.u_lamina_color.value = typeof v === 'string' ? new THREE.Color(v).convertSRGBToLinear() : v\r\n  }\r\n  get color() {\r\n    return this.uniforms?.u_lamina_color?.value\r\n  }\r\n  set alpha(v: number) {\r\n    this.uniforms.u_lamina_alpha.value = v\r\n  }\r\n  get alpha() {\r\n    return this.uniforms.u_lamina_alpha.value\r\n  }\r\n}\r\n\r\nexport { Abstract, Color, Depth, Displace, Fresnel, Gradient, LayerMaterial, Matcap, Noise, Normal, Texture }\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA,WAAO,UAAU;AAAA;AAAA,MAEb;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MAGA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAAA;AAAA;;;AC7FA;AAAA;AAAA,WAAO,UAAU;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAAA;AAAA;;;AC9CA;AAAA;AAAA,WAAO,UAAU;AAAA;AAAA,MAEf;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAAA;AAAA;;;ACrJA;AAAA;AAAA,QAAI,OAAO;AAEX,WAAO,UAAU,KAAK,MAAM,EAAE,OAAO;AAAA,MAClC;AAAA,MACC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;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",
  "names": ["last", "j", "j", "j", "s", "k", "j", "k", "i", "BlendModes", "NoiseTypes", "MappingTypes", "ShadingTypes", "getUniform", "value", "Color", "getSpecialParameters", "label", "getLayerMaterialArgs", "color", "alpha", "lighting", "name", "rest", "isSerializableType", "prop", "Vector3", "Vector2", "Vector4", "Matrix3", "Matrix4", "serializeProp", "Texture", "Abstract", "c", "props", "onParse", "MathUtils", "uniforms", "e", "a", "v", "_a", "key", "propName", "properties", "constructor", "shaders", "tokens", "tokenize", "descoped", "descope", "funcs", "tokenFunctions", "mainIndex", "variables", "stringify", "funcBodies", "index", "_value", "obj", "slice", "shader", "isVertex", "s", "returnValue", "sReplaced", "returnVariable", "blendMode", "b", "options", "nonUniformPropKeys", "nonUniformProps", "k", "_Color", "_Depth", "self", "mapping", "uuid", "type", "Depth", "_Displace", "noiseFunc", "Displace", "_Fresnel", "Fresnel", "_Gradient", "Gradient", "_Matcap", "Matcap", "_Noise", "Noise", "_Normal", "Normal", "_Texture", "BlendModesChunk", "HelpersChunk", "NoiseChunk", "LayerMaterial", "CustomShaderMaterial", "layers", "_baseColor", "_alpha", "vertexVariables", "fragmentVariables", "vertexShader", "fragmentShader", "l", "_b"]
}
